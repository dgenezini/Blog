[{"content":"Introdu√ß√£o Com o release do .NET 7, a Microsoft incluiu uma funcionalizade para renderizar componentes Blazor em aplica√ß√µes JavaScript (RegisterCustomElement\u0026lt;T\u0026gt;). Isso ajuda quem quer migrar lentamente de aplica√ß√µes JavaScript para Blazor, mas infelizmente, n√£o funciona para expor componentes Blazor como microfrontends, pois funciona apenas para aplica√ß√µes JavaScript hospedadas junto com a aplica√ß√£o Blazor.\nNeste post, vou apresentar um pacote nuget que criei como prot√≥tipo para tentar resolver esse problema, expondo componentes Blazor com module federation para o consumo de outras aplica√ß√µes.\nO que √© Module Federation? Module Federation √© uma funcionalidade do webpack que nos possibilita expor m√≥dulos JavaScript JavaScript para que outras aplica√ß√µes consumam. Esses m√≥dulos federados podem ser implantados de forma independente e s√£o isolados uns dos outros, possibilitando construir aplica√ß√µes com a arquitetura de microfrontends.\nO que √© Arquitetura de Microfrontend? A arquitetura de Microfrontend √© similar √† arquitetura de Microsservi√ßos, mas aplicada √†s aplica√ß√µes frontend. Uma aplica√ß√£o desenvolvida com a arquitetura de microfrontend √© composta por uma ou mais microfrontends, componentes autocontidos, publicados individualmente e que podem ser desenvolvidos usando tecnologias diferentes uns dos outros.\nNa imagem abaixo, podemos ver uma aplica√ß√£o com quatro microfrontends. Cada um desenvolvido por um time diferente e com tecnologias diferentes.\nMais sobre microfrontends nesse post do Martin Fowler.\nAngular Module Federation wrapper para Blazor Ressalva: Esse pacote √© um prot√≥tipo e n√£o est√° pronto para ser usado em produ√ß√£o.\nAp√≥s a instala√ß√£o do pacote nuget, ele ir√° gerar uma aplica√ß√£o Angular em tempo de compila√ß√£o, expondo os componentes Blazor atrav√©s do module federation.\nOs componentes expostos aceitam par√¢metros de entrada e inscri√ß√£o a eventos.\nConfigura√ß√µes na aplica√ß√£o Blazor Primeiro, instale o pacote nuget Blazor.ModuleFederation.Angular:\nInstall-Package Blazor.ModuleFederation.Angular O c√≥digo fonte da aplica√ß√£o Angular √© gerado por uma tarefa do MSBuild. Para isso, precisamos configurar quais componentes ser√£o expostos.\nPokemonCards.razor: No arquivo .razor do componente, inclua o atributo GenerateModuleFederationComponent.\n1 2 3 4 @attribute [GenerateModuleFederationComponent] @using Blazor.ModuleFederation.Angular; ... Program.cs: No arquivo Program.cs, registre o componente com o m√©todo RegisterForModuleFederation.\n1 2 3 4 5 var builder = WebAssemblyHostBuilder.CreateDefault(args); builder.RootComponents.RegisterForModuleFederation\u0026lt;PokemonCards\u0026gt;(); ... Project.csproj: No arquivo .csproj, configure os seguintes par√¢metros:\nModuleFederationName: Nome do m√≥dulo que ser√° exposto; MicroFrontendBaseUrl: URL onde a aplica√ß√£o Blazor ser√° publicada; BuildModuleFederationScript: Habilitar ou desabilitar a gera√ß√£o do wrapper Angular na compila√ß√£o; IsProduction: Se a aplica√ß√£o Angular ser√° compilada com configura√ß√µes de produ√ß√£o; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;PropertyGroup\u0026gt; \u0026lt;ModuleFederationName\u0026gt;blazormodule\u0026lt;/ModuleFederationName\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;PropertyGroup Condition=\u0026#34;\u0026#39;$(Configuration)\u0026#39; == \u0026#39;DEBUG\u0026#39;\u0026#34;\u0026gt; \u0026lt;MicroFrontendBaseUrl\u0026gt;http://localhost:5289/\u0026lt;/MicroFrontendBaseUrl\u0026gt; \u0026lt;BuildModuleFederationScript\u0026gt;False\u0026lt;/BuildModuleFederationScript\u0026gt; \u0026lt;IsProduction\u0026gt;False\u0026lt;/IsProduction\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;PropertyGroup Condition=\u0026#34;\u0026#39;$(Configuration)\u0026#39; == \u0026#39;RELEASE\u0026#39;\u0026#34;\u0026gt; \u0026lt;MicroFrontendBaseUrl\u0026gt;http://localhost:8080/\u0026lt;/MicroFrontendBaseUrl\u0026gt; \u0026lt;BuildModuleFederationScript\u0026gt;True\u0026lt;/BuildModuleFederationScript\u0026gt; \u0026lt;IsProduction\u0026gt;True\u0026lt;/IsProduction\u0026gt; \u0026lt;/PropertyGroup\u0026gt; Configura√ß√µes na aplica√ß√£o Host PokemonCardsLoaderComponent: Crie um componente para carregar o componente Blazor remoto. N√£o esque√ßa de inclu√≠-lo no m√≥dulo da aplica√ß√£o.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import { Component, OnInit, ViewContainerRef, ComponentRef, EventEmitter } from \u0026#39;@angular/core\u0026#39;; import { loadRemoteModule } from \u0026#39;@angular-architects/module-federation\u0026#39;; @Component({ selector: \u0026#39;pokemon-cards-loader\u0026#39;, template: \u0026#39;\u0026#39; }) export class PokemonCardsLoaderComponent implements OnInit { constructor( private vcref: ViewContainerRef ) {} async ngOnInit() { const { PokemonCardsComponent } = await loadRemoteModule({ remoteEntry: \u0026#39;http://localhost:8080/js/remoteEntry.js\u0026#39;, remoteName: \u0026#39;blazormodule\u0026#39;, exposedModule: \u0026#39;./PokemonCards\u0026#39;, }); const componentRef: ComponentRef\u0026lt;{ startFromId: number; onDataLoaded: EventEmitter\u0026lt;any\u0026gt;; }\u0026gt; = this.vcref.createComponent(PokemonCardsComponent); componentRef.instance.startFromId = 810; componentRef.instance.onDataLoaded.subscribe(evt =\u0026gt; console.log(\u0026#39;API Data Loaded\u0026#39;)); } } AppComponent: Inclua o componente no HTML.\n1 2 3 4 5 6 7 \u0026lt;div class=\u0026#34;toolbar\u0026#34; role=\u0026#34;banner\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;header-title\u0026#34;\u0026gt;Host App\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34; role=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;pokemon-cards-loader\u0026gt;\u0026lt;/pokemon-cards-loader\u0026gt; \u0026lt;/div\u0026gt; webpack.config.js Importe o componente Blazor na se√ß√£o ModuleFederationPlugin.remotes.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 const ModuleFederationPlugin = require(\u0026#34;webpack/lib/container/ModuleFederationPlugin\u0026#34;); const mf = require(\u0026#34;@angular-architects/module-federation/webpack\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const share = mf.share; const sharedMappings = new mf.SharedMappings(); sharedMappings.register( path.join(__dirname, \u0026#39;tsconfig.json\u0026#39;), [/* mapped paths to share */]); module.exports = { output: { uniqueName: \u0026#34;hostApp\u0026#34;, publicPath: \u0026#34;auto\u0026#34; }, optimization: { runtimeChunk: false }, resolve: { alias: { ...sharedMappings.getAliases(), } }, experiments: { outputModule: true }, plugins: [ new ModuleFederationPlugin({ library: { type: \u0026#34;module\u0026#34; }, remotes: { blazormodule: \u0026#39;blazormodule@http://localhost:8080/js/remoteEntry.js\u0026#39; }, shared: share({ \u0026#34;@angular/core\u0026#34;: { singleton: true, strictVersion: true, requiredVersion: \u0026#39;auto\u0026#39; }, \u0026#34;@angular/common\u0026#34;: { singleton: true, strictVersion: true, requiredVersion: \u0026#39;auto\u0026#39; }, \u0026#34;@angular/common/http\u0026#34;: { singleton: true, strictVersion: true, requiredVersion: \u0026#39;auto\u0026#39; }, \u0026#34;@angular/router\u0026#34;: { singleton: true, strictVersion: true, requiredVersion: \u0026#39;auto\u0026#39; }, ...sharedMappings.getDescriptors() }) }), sharedMappings.getPlugin() ], }; Application de exemplo https://github.com/dgenezini/BlazorModuleFederationSample\nProblemas e limita√ß√µes atuais Funciona apenas com Blazor WebAssembly; Apenas uma aplica√ß√£o Blazor pode ser carregada pelo host (a aplica√ß√£o pode expor diversos componentes); Servidor da aplica√ß√£o Blazor precisa ter CORS habilitado. Links https://www.nuget.org/packages/Blazor.ModuleFederation.Angular https://github.com/dgenezini/Blazor.ModuleFederation.Angular https://github.com/dgenezini/BlazorModuleFederationSample https://tautorn.github.io/micro-frontends/ ","date":"2022-11-17T09:50:00-03:00","image":"https://blog.genezini.com/p/introducing-module-federation-for-blazor-components/cover.jpg","permalink":"https://blog.genezini.com/pt/p/apresentando-module-federation-para-blazor/","title":"Apresentando module federation para Blazor"},{"content":"Introdu√ß√£o Testes automatizados s√£o um requisito para garantir a entrega de um produto de qualidade para nossos usu√°rios. Eles ajudam a encontrar bugs e requisitos n√£o cumpridos ainda em tempo de desenvolvimento, mas tamb√©m diminuem o custo de manuten√ß√£o fazendo altera√ß√µes futuras no c√≥digo mais seguras. Al√©m disso, o ato de escrever c√≥digo test√°vel, por si s√≥, aumenta a qualidade do c√≥digo, pois c√≥digo test√°vel precisa ser desacoplado.\nNesse √∫ltimo post da s√©rie, vou mostrar como analisar e validar uma cobertura m√≠nima de c√≥digo nas nossas aplica√ß√µes, al√©m de como utilizar testes de integra√ß√£o para aumentar a cobertura do c√≥digo.\nO que √© cobertura de c√≥digo? Cobertura de c√≥digo √© uma m√©trica de software que mostra o quanto do nosso c√≥digo √© executado (coberto) por nossos testes automatizados. Ela √© expressa em um percentual e pode ser calculada de diferentes formas, baseada na quantidade de linhas ou de branches, por exemplo. Quanto maior o percentual, mais do nosso c√≥digo est√° sendo testado.\nAnalisando a cobertura de c√≥digo da nossa aplica√ß√£o Nesse exemplo, temos uma API ASP.NET Core com um use case simples que verifica se um n√∫mero √© par ou √≠mpar e retorna uma string:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using CodeCoverageSample.Interfaces; namespace CodeCoverageSample.UseCases; public class IsEvenUseCase : IIsEvenUseCase { public string IsEven(int number) { if (number % 2 == 0) { return \u0026#34;N√∫mero √© par\u0026#34;; } else { return \u0026#34;N√∫mero √© √≠mpar\u0026#34;; } } } Por enquanto, temos apenas um teste de unidade para essa classe:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using CodeCoverageSample.UseCases; namespace CodeCoverageSample.UnitTests; public class IsEvenUseCaseTests { [Fact] public void NumeroPar_RetornaPar() { //Arrange var isEvenUseCase = new IsEvenUseCase(); //Act var result = isEvenUseCase.IsEven(2); //Assert Assert.Equal(\u0026#34;N√∫mero √© par\u0026#34;, result); } } Para analisar a cobertura de c√≥digo da nossa aplica√ß√£o, primeiro precisamos instalar em nosso projeto de teste o pacote nuget coverlet.msbuild, que faz a integra√ß√£o do Coverlet com o MSBuild:\nInstall-Package coverlet.msbuild Ent√£o, executamos o comando dotnet test com os par√¢metros do Coverlet no diret√≥rio da nossa solution ou no diret√≥rio do projeto da nossa API:\ndotnet test -p:CollectCoverage=true -p:CoverletOutputFormat=opencover -p:CoverletOutput=../TestResults Estamos usando os seguintes par√¢metros:\nCollectCoverage: Informa o dotnet test para usar o Coverlet para coletar dados de cobertura de c√≥digo; CoverletOutputFormat: Formato do relat√≥rio que ser√° gerado pelo Coverlet (opencover, cobertura, json). Detalhes aqui; CoverletOutput: Caminho onde o relat√≥rio ser√° gravado. Esse caminho √© relativo ao projeto de teste; O comando ir√° mostrar uma tabela com a cobertura de c√≥digo e gerar um arquivo de relat√≥rio com o nome TestResults.opencover.xml:\n‚ö†Ô∏è Podemos tamb√©m executar o Coverlet na linha de comando com o pacote nuget coverlet.collector, por√©m ele possui poucos par√¢metros e n√£o imprime os resultados na linha de comando. Mais detalhes aqui;\nGerando relat√≥rios em HTML O Coverlet gera relat√≥rios em formatos que n√£o s√£o facilmente lidos por humanos, ent√£o precisamos gerar um relat√≥rio HTML baseado no relat√≥rio do Coverlet. Para isso, vamos usar uma ferramenta chamada ReportGenerator.\nInstalando o ReportGenerator O ReportGenerator √© instalado como um global tool do .NET.\nPara isso, executamos o comando abaixo:\ndotnet tool install --global dotnet-reportgenerator-globaltool Gerando um relat√≥rio em HTML a partir de um relat√≥rio opencover Para gerar um relat√≥rio em HTML a partir de um relat√≥rio do Coverlet, executamos o comando abaixo:\nreportgenerator \u0026#34;-reports:TestResults.opencover.xml\u0026#34; \u0026#34;-targetdir:coveragereport\u0026#34; -reporttypes:Html Estamos usando os seguintes par√¢metros:\nreports: Caminho para o relat√≥rio do Coverlet; targetdir: Caminho onde o relat√≥rio HTML ser√° salvo; reporttypes: Formato em que o relat√≥rio ser√° salvo. O retorno do comando mostrar√° o caminho relativo para o relat√≥rio gerado: coveragereport\\index.html.\nAbrindo o arquivo coveragereport\\index.html n√≥s podemos ver a cobertura de linhas e de branches do projeto:\nClicando em CodeCoverageSample.UseCases.IsEvenUseCase n√≥s podemos ver detalhes da cobertura de c√≥digo da classe, cobertura de c√≥digo por m√©todo (na tabela):\nCobertura de linhas vs cobertura de branches Mas o que √© cobertura de linhas e cobertura de branches?\nCobertura de linhas: Indica o percentual de linhas que est√£o cobertos pelos testes; Cobertura de branches: Indica o percentual de caminhos l√≥gicos que est√£o cobertos pelos testes (if, else, condi√ß√µes em um switch, etc). No exemplo abaixo, podemos ver que duas linhas no branch else n√£o est√£o sendo cobertas pelos testes.\nIsso ir√° resultar em:\n50% de cobertura de branches, porque apenas a branch do if est√° coberta; 71.4% de cobertura de linhas, porque apenas 5 das 7 linhas est√£o cobertas. Cobertura de c√≥digo no Visual Studio O Visual Studio possui uma extens√£o chamada Run Coverlet Report que o integra com Coverlet e o ReportGenerator.\nPrimeiro, precisamos instalar o pacote nuget coverlet.collector nos nossos projetos de teste. Projetos de teste criados com o template do Xunit j√° vem com esse pacote instalado por padr√£o. Install-Package coverlet.collector Depois, acesse Extensions \u0026gt; Manage extensions e instale a extens√£o Run Coverlet Report. Acesse a nova op√ß√£o Tools \u0026gt; Run Code Coverage. O Visual Studio ir√° gerar e exibir um relat√≥rio em HTML. Al√©m disso, ap√≥s executar a an√°lise de cobertura de c√≥digo, o Visual studio ir√° ler o relat√≥rio do coverlet e mostrar a cobertura no nosso fonte:\nAumentando nossa cobertura de c√≥digo Corrigindo os testes de unidade Agora vamos implementar o m√©todo NumeroImpar_RetornaImpar para testar o caminho l√≥gico que n√£o testamos anteriormente:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 using CodeCoverageSample.UseCases; namespace CodeCoverageSample.UnitTests; public class IsEvenUseCaseTests { [Fact] public void NumeroPar_RetornaPar() { //Arrange var isEvenUseCase = new IsEvenUseCase(); //Act var result = isEvenUseCase.IsEven(2); //Assert Assert.Equal(\u0026#34;N√∫mero √© par\u0026#34;, result); } [Fact] public void NumeroImpar_RetornaImpar() { //Arrange var isEvenUseCase = new IsEvenUseCase(); //Act var result = isEvenUseCase.IsEven(3); //Assert Assert.Equal(\u0026#34;N√∫mero √© √≠mpar\u0026#34;, result); } } Isso ir√° aumentar nossa cobertura de c√≥digo para 50% das branches e 22.58% das linhas:\nE 100% para a classe IsEvenUseCase:\nImplementando testes de integra√ß√£o Testes de integra√ß√£o com a classe WebApplicationFactory (Mais sobre aqui) tamb√©m s√£o considerados nos relat√≥rios de cobertura de c√≥digo. Vamos ver a cobertura de c√≥digo das classes IsEvenController e Program:\nAgora vamos implementar um teste de integra√ß√£o simples. Ele ir√° apenas instanciar nossa API e fazer uma chamada passando um n√∫mero e validando o retorno:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 using Microsoft.AspNetCore.Mvc.Testing; using System.Net; namespace CodeCoverageSample.UnitTests.IntegrationTests; public class IsEvenIntegrationTest : IClassFixture\u0026lt;WebApplicationFactory\u0026lt;Program\u0026gt;\u0026gt; { private readonly WebApplicationFactory\u0026lt;Program\u0026gt; _factory; public IsEvenIntegrationTest(WebApplicationFactory\u0026lt;Program\u0026gt; factory) { _factory = factory; } [Theory] [InlineData(2, \u0026#34;N√∫mero √© par\u0026#34;)] [InlineData(3, \u0026#34;N√∫mero √© √≠mpar\u0026#34;)] public async Task Numero_RetornaCorretoEOk(int number, string expectedResult) { var HttpClient = _factory .CreateClient(); //Act var HttpResponse = await HttpClient.GetAsync($\u0026#34;/iseven/{number}\u0026#34;); //Assert Assert.Equal(HttpStatusCode.OK, HttpResponse.StatusCode); var ResponseStr = await HttpResponse.Content.ReadAsStringAsync(); Assert.Equal(expectedResult, ResponseStr); } } Agora geramos o relat√≥rio de cobertura de c√≥digo novamente e as classes IsEvenController e Program est√£o cobertas por nossos testes:\nRemovendo c√≥digo da an√°lise de cobertura de c√≥digo Se quisermos remover uma classe ou m√©todo da an√°lise de cobertura de c√≥digo, podemos decorar ele com o atributo ExcludeFromCodeCoverage:\n1 2 3 4 5 6 7 8 9 using System.Diagnostics.CodeAnalysis; namespace CodeCoverageSample; [ExcludeFromCodeCoverage] public class NaoMeTeste { ... } ‚ÑπÔ∏è N√≥s tamb√©m podemos criar atributos personalizados para excluir c√≥digo da cobertura de c√≥digo. Detalhes aqui.\nIgnorando auto-properties O Coverlet possui o par√¢metro SkipAutoProps que permite excluir as auto-properties da an√°lise de cobertura de c√≥digo.\nPor exemplo, essa classe n√£o possui nenhuma l√≥gica e n√£o precisa que os m√©todos get e set das suas propriedades sejam testados:\n1 2 3 4 5 6 7 namespace CodeCoverageSample; public class SemLogicaAqui { public int Id { get; set; } public int Nome { get; set; } } Basta passar o par√¢metro SkipAutoProps como true quando executar o comando para avaliar a cobertura de c√≥digo:\ndotnet test -p:CollectCoverage=true -p:CoverletOutputFormat=opencover -p:CoverletOutput=TestResults -p:SkipAutoProps=true ‚ö†Ô∏è Infelizmente, a extens√£o Run Coverage Report ainda n√£o permite configurarmos os par√¢metros do coverlet. Existe um pull request aberto com essa funcionalidade aguardando aprova√ß√£o aqui.\nValidando uma cobertura m√≠nima na pipeline de build Assim como com as regras de estilo e qualidade do c√≥digo, que eu falei no meu post anterior, precisamos validar um percentual m√≠nimo de cobertura de c√≥digo na nossa pipeline de build para manter o n√≠vel de qualidade no nosso c√≥digo. O Coverlet tem um par√¢metro Threshold onde podemos definir o percentual m√≠nimo para caso esse percentual n√£o seja atingido, a execu√ß√£o dos testes retorne uma falha:\ndotnet test -p:CollectCoverage=true -p:CoverletOutputFormat=opencover -p:CoverletOutput=TestResults -p:SkipAutoProps=true -p:Threshold=80 Tamb√©m podemos passar o par√¢metro ThresholdType para definir qual tipo de cobertura validar. N√£o especificando, a valida√ß√£o ser√° feita em todos os tipos de cobertura (Linha, Branch e M√©todo). Detalhes aqui.\nRefer√™ncias e links https://github.com/coverlet-coverage/coverlet https://github.com/coverlet-coverage/coverlet/blob/master/Documentation/MSBuildIntegration.md https://github.com/coverlet-coverage/coverlet/blob/master/Documentation/VSTestIntegration.md https://github.com/danielpalme/ReportGenerator https://marketplace.visualstudio.com/items?itemName=ChrisDexter.RunCoverletReport https://github.com/the-dext/RunCoverletReport/blob/master/README.md ","date":"2022-11-03T08:10:00-03:00","image":"https://blog.genezini.com/pt/p/analisando-e-validando-cobertura-de-codigo-no-.net-com-coverlet/cover.pt.png","permalink":"https://blog.genezini.com/pt/p/analisando-e-validando-cobertura-de-codigo-no-.net-com-coverlet/","title":"Analisando e validando cobertura de c√≥digo no .NET com Coverlet"},{"content":"Introdu√ß√£o A an√°lise est√°tica de c√≥digo √© uma √≥tima ferramenta para detectar alguns tipos de erros no seu c√≥digo, como por exemplo, n√£o liberar objetos que implementam IDisposable. Al√©m disso, ela ajuda a validar se o c√≥digo escrito est√° seguindo um padr√£o definido, por exemplo, utilizando PascalCase para nomes de classes e camelCase para nomes de par√¢metros.\nNesse post eu vou mostrar como usar os Roslyn Analyzers com C# para validar alguns padr√µes de qualidade e estilo de c√≥digo, exibindo erros em tempo de compila√ß√£o caso alguma das regras n√£o seja respeitada, n√£o permitindo que as altera√ß√µes cheguem √†s branches protegidas do reposit√≥rio.\nRoslyn Analyzers Roslyn √© o compilador do .NET. Roslyn Analyzers s√£o ferramentas de an√°lise est√°tica para o Roslyn. Eles inspecionam o c√≥digo para estilo, qualidade, e pr√°ticas que possivelmente causam bugs. Eles funcionam de acordo com regras definidas e severidades que s√£o configuradas no arquivo EditorConfig.\nO .NET 5 e vers√µes superiores possuem os analisadores habilitados por padr√£o. Para habilitar em vers√µes anteriores do .NET, voc√™ pode configurar a propriedade EnableNETAnalyzers como true em projetos que utilizam um project SDK ou instal√°-los atrav√©s de um pacote nuget:\nConfigurando EnableNETAnalyzers no arquivo do projeto 1 2 3 \u0026lt;PropertyGroup\u0026gt; \u0026lt;EnableNETAnalyzers\u0026gt;true\u0026lt;/EnableNETAnalyzers\u0026gt; \u0026lt;/PropertyGroup\u0026gt; Instalando atrav√©s de um pacote nuget Install-Package Microsoft.CodeAnalysis.NetAnalyzers Habilitando mais analisadores Por padr√£o, apenas algumas regras s√£o habilitadas, mas podemos configurar isso com a propriedade AnalysisMode no arquivo de projeto:\n1 2 3 \u0026lt;PropertyGroup\u0026gt; \u0026lt;AnalysisMode\u0026gt;Recommended\u0026lt;/AnalysisMode\u0026gt; \u0026lt;/PropertyGroup\u0026gt; Os valores da propriedade AnalysisMode s√£o diferentes entre os SDKs do .NET 6 e .NET 5. Detalhes aqui.\nComo habilitar os analisadores .NET no VS Code Os analisadores .NET funcionam por padr√£o no Visual Studio, mas precisam ser habilitados no VS Code.\n1 - Acesse File \u0026gt; Preferences \u0026gt; Settings.\n2 - Navegue at√© Extensions \u0026gt; C# configuration ou pesquise por omnisharp.enableRoslynAnalyzers.\n3 - Selecione a op√ß√£o Omnisharp: Enable Roslyn Analyzers.\n4 - Navegue at√© Extensions \u0026gt; C# configuration ou pesquise por omnisharp.enableEditorConfigSupport.\n5 - Selecione a op√ß√£o Omnisharp: Enable Editor Config Support.\n6 - Reinicie a extens√£o C#/Omnisharp ou o VS Code.\nTipos de regras Os analisadores .NET est√£o divididos em v√°rias categorias, mas aqui listo algumas apenas para explicar como elas interagem com as funcionalidades do Visual Studio.\nFormata√ß√£o padr√£o: Op√ß√µes padr√µes do Editorconfig, como tamanho da indenta√ß√£o e utiliza√ß√£o de tabs ou espa√ßos;\nEstilo de c√≥digo - Formata√ß√£o .NET: Indenta√ß√£o espec√≠fica da linguagem, espa√ßos em branco, e wrapping. Por exemplo, usar espa√ßos antes de par√™nteses nas defini√ß√µes de m√©todos.\nEstilo de c√≥digo - Linguagens .NET: Regras espec√≠ficas do C# e Visual Basic. Exemplos: usar var em vez de um tipo expl√≠cito, preferir propriedades autom√°ticas em vez de backing fields.\nEstilo de c√≥digo - Conven√ß√µes de nomenclatura: Regras sobre nomenclatura de elementos, como for√ßar PascalCase para nomes de classes e a palavra Async no final do nome de m√©todos ass√≠ncronos.\nEstilo de c√≥digo - C√≥digo desnecess√°rio: Regras para c√≥digo que nunca √© executado como vari√°veis n√£o utilizadas.\nQualidade de c√≥digo: Regras para melhorar a qualidade do c√≥digo. Essas regras ajudam a identificar c√≥digo que podem causar bugs ou problemas de seguran√ßa. Exemplos: N√£o declarar membros est√°ticos em tipos gen√©ricos, e Enums que n√£o contenham um valor para zero.\nA tabela abaixo mostra como as funcionalidades do Visual Studio aplicam as corre√ß√µes para cada um desses tipos de regras.\nCorre√ß√µes aplicadas para üñπ Formata√ß√£o üßπ Code Cleanup üí° Code Fix Formata√ß√£o padr√£o ‚úîÔ∏è ‚úîÔ∏è ‚úîÔ∏è Formata√ß√£o .NET ‚úîÔ∏è ‚úîÔ∏è ‚úîÔ∏è Linguagens .NET ‚úîÔ∏è ‚úîÔ∏è Conven√ß√µes de nomenclatura ‚úîÔ∏è C√≥digo desnecess√°rio ‚ùó ‚úîÔ∏è Qualidade de c√≥digo ‚ùó ‚ùó Apenas algumas regras s√£o aplicadas.\nüí° No post anterior desta s√©rie, eu explico como configurar o Visual Studio para aplicar essas regras no Code Cleanup e como executar automaticamente o Code Cleanup ao salvar os arquivos.\nValidando regras no nosso c√≥digo As regras dos analisadores s√£o configuradas no arquivo EditorConfig (que eu expliquei na Parte 1 dessa s√©rie) e as severidades podem ser definidas em tr√™s n√≠veis. Os conflitos nas regras s√£o resolvidos na seguinte ordem:\nRegras espec√≠ficas Categorias de regras Todas as regras No exemplo abaixo, Viola√ß√£o de regras de nomenclatura (IDE1006) ser√£o consideradas como Warning, porque est√£o definidas no n√≠vel da regra espec√≠fica:\n1 2 3 4 5 6 # Defines that all analyzers rules are suggestions dotnet_analyzer_diagnostic.severity = suggestion # Defines that all Code Style analyzers rules are errors dotnet_analyzer_diagnostic.category-Style.severity = error # Defines that the rule IDE1006 is a warning dotnet_diagnostic.IDE1006.severity = warning 1. Crie um arquivo EditorConfig pelo Visual Studio Primeiro, precisamos criar um arquivo EditorConfig com a configura√ß√£o das regras que usaremos como padr√£o.\nO Visual Studio possui uma ferramenta para ajudar a configurar as regras de estilo de c√≥digo do seu EditorConfig, mostrando snippets de c√≥digo de como a regra funciona.\nAcesse Tools \u0026gt; Options \u0026gt; Text Editor \u0026gt; C# \u0026gt; Code Style; Configure suas prefer√™ncias de estilo de c√≥digo nos menus General, Formatting e Naming. ‚ö†Ô∏è N√£o se preocupe em configurar as severidades aqui; algumas delas s√£o respeitadas apenas pelo Visual Studio e n√£o s√£o validadas na compila√ß√£o e em outras IDEs; De volta ao menu General, clique em Generate .editoconfig file from settings e salve o arquivo na pasta onde a solu√ß√£o do seu projeto (.sln) est√°. ‚ö†Ô∏è Se voc√™ n√£o estiver usando Visual Studio, voc√™ pode usar um exemplo e alterar para suas prefer√™ncias, como esse do Roslyn.\n2. Configure todos os projetos para usar os analisadores .NET Analyzers recomendados Em seguida, configuramos a propriedade AnalysisMode em todos os projetos da nossa solu√ß√£o.\nPara o SDK do .NET 6 e superiores, configure como Recommended ou All.\n1 2 3 \u0026lt;PropertyGroup\u0026gt; \u0026lt;AnalysisMode\u0026gt;Recommended\u0026lt;/AnalysisMode\u0026gt; \u0026lt;/PropertyGroup\u0026gt; 3. Configure a severidade de todos os analisadores como Error No nosso EditorConfig, inclua a linha abaixo para configurar a severidade de todas as regras como error.\n# Configura a severidade como error para todos os analisadores dotnet_analyzer_diagnostic.severity = error 4. Corrija os erro e sobrescreva as regras que n√£o deseja utilizar Se voc√™ est√° habilitando os analisadores em um projeto existente, muitos erros v√£o ser mostrados. Corrija-os e sobrescreva as severidades das regras que n√£o se aplicam ou que ser√£o corrigidas em outro momento.\nüí° No post anterior desta s√©rie, eu explico como adicionar fixers ao Code Cleanup do Visual Studio. Voc√™ pode personalizar ele para corrigir algumas das viola√ß√µes de regras.\nConfigurando a severidade das regras diretamente no arquivo EditorConfig 1 2 3 4 5 6 7 # Outras regras ... # Configura a severity como none para as regras que n√£o se aplicam dotnet_diagnostic.IDE0075.severity = none # Configura a severity como warning para as regras que ser√£o resolvidas no futuro dotnet_diagnostic.IDE0047.severity = warning Configurando a severidade das regras pela lista de erros do Visual Studio Para erros sendo mostrados na lista de erros, voc√™ pode clicar com bot√£o direito na mensagem e selecionar Set severity \u0026gt; Choose a severity. A severidade ser√° adicionada ao arquivo EditorConfig.\nConfigurando a severidade das regras pelo Solution Explorer do Visual Studio Pelo Solution Explorer, abra Dependencies \u0026gt; Analyzers abaixo do projeto, depois clique com o bot√£o direito na regra e selecione Set severity \u0026gt; Choose a severity. A severidade ser√° adicionada ao arquivo EditorConfig.\n5. Validando as regras na compila√ß√£o Habilitar os analisadores apenas mostrar√° as mensagens na sua IDE. Para realmente validar se as regras est√£o sendo cumpridas, precisamos informar o compilador para falhar em caso de viola√ß√µes das regras, bloqueando as altera√ß√µes de subirem para as branches protegidas do reposit√≥rio.\nPara isso, precisamos configurar a propriedade EnforceCodeStyleInBuild como true em todos os projetos da nossa solu√ß√£o.\n1 2 3 \u0026lt;PropertyGroup\u0026gt; \u0026lt;EnforceCodeStyleInBuild\u0026gt;true\u0026lt;/EnforceCodeStyleInBuild\u0026gt; \u0026lt;/PropertyGroup\u0026gt; Exemplos das regras sendo validadas Regras sendo validadas no Visual Studio Regras sendo validadas no VS Code Regras sendo validadas na linha de comando com dotnet build Criando conven√ß√µes de nomenclatura adicionais Abaixo temos algumas conven√ß√µes de nomenclatura do C#:\nS√≠mbolo Conven√ß√£o Exemplo classes/records/structs PascalCase PhysicalAddress interfaces \u0026ldquo;I\u0026rdquo;+PascalCase IWorkerQueue membros p√∫blicos PascalCase StartEventProcessing campos privados/internos \u0026ldquo;_\u0026quot;+camelCase _workerQueue campos est√°ticos \u0026ldquo;s_\u0026quot;+camelCase s_workerQueue vari√°veis locais *Ô∏è camelCase isValid par√¢metros camelCase name m√©todos ass√≠ncronos PascalCase+\u0026ldquo;Async\u0026rdquo; GetStringAsync Mais detalhes aqui.\nPor padr√£o, o Visual Studio n√£o cria conven√ß√µes de nomenclatura para campos est√°ticos, vari√°veis locais, par√¢metros e m√©todos async. Se quisermos us√°-las, temos que criar as conven√ß√µes manualmente, como mostro abaixo.\n*Ô∏è N√£o especificado na documenta√ß√£o, mas o Roslyn usa essa conven√ß√£o.\nCriando conven√ß√µes de nomenclatura para m√©todos async 1 2 3 4 5 6 7 8 9 10 dotnet_naming_rule.async_methods_should_be_pascalcase_async.severity = error dotnet_naming_rule.async_methods_should_be_pascalcase_async.symbols = async_methods dotnet_naming_rule.async_methods_should_be_pascalcase_async.style = pascalcase_async dotnet_naming_symbols.async_methods.applicable_kinds = method dotnet_naming_symbols.async_methods.applicable_accessibilities = * dotnet_naming_symbols.async_methods.required_modifiers = async dotnet_naming_style.pascalcase_async.required_suffix = Async dotnet_naming_style.pascalcase_async.capitalization = pascal_case Criando conven√ß√µes de nomenclatura para vari√°veis locais e par√¢metros 1 2 3 4 5 6 7 dotnet_naming_rule.locals_and_parameters_should_be_pascal_case.severity = error dotnet_naming_rule.locals_and_parameters_should_be_pascal_case.symbols = locals_and_parameters dotnet_naming_rule.locals_and_parameters_should_be_pascal_case.style = camel_case dotnet_naming_symbols.locals_and_parameters.applicable_kinds = parameter, local dotnet_naming_style.camel_case.capitalization = camel_case Como ignorar a regra CA1707 (Identifiers should not contain underscores) em projetos de testes Algumas conven√ß√µes para nomenclatura de testes utilizam underscore. Se esse for o seu caso, voc√™ vai receber uma viola√ß√£o da regra CA1707. Para desabilitar essa regra apenas nos projetos de testes, crie um arquivo com o nome GlobalSuppressions.cs na raiz do seu projeto de testes com o conte√∫do abaixo.\n1 2 3 using System.Diagnostics.CodeAnalysis; [assembly: SuppressMessage(\u0026#34;Naming\u0026#34;, \u0026#34;CA1707:Identifiers should not contain underscores\u0026#34;, Justification = \u0026#34;Not applicable for test names\u0026#34;, Scope = \u0026#34;module\u0026#34;)] Analisadores de terceiros Existem analisadores de terceiros que podem ter regras adicionais que podem ser √∫teis. Aqui est√£o alguns:\nRoslynator StyleCop Sonar Analyzer Refer√™ncias e Links https://learn.microsoft.com/en-us/visualstudio/code-quality/install-net-analyzers?view=vs-2022 https://www.jetbrains.com/help/rider/Using_EditorConfig.html#export-code-style-settings https://marketplace.visualstudio.com/items?itemName=MadsKristensen.EditorConfig ","date":"2022-10-25T08:30:00-03:00","image":"https://blog.genezini.com/pt/p/validando-regras-de-estilo-de-codigo-no-.net-em-tempo-de-compilacao/cover.pt.png","permalink":"https://blog.genezini.com/pt/p/validando-regras-de-estilo-de-codigo-no-.net-em-tempo-de-compilacao/","title":"Validando regras de estilo de c√≥digo no .NET em tempo de compila√ß√£o"},{"content":"Introduction Quando trabalhamos com outras pessoas, usando editores e IDEs variadas, √© comum que haja diferen√ßas nas configura√ß√µes dos mesmo, fazendo com que se perca consist√™ncia no estilo de formata√ß√£o do c√≥digo. Por exemplo:\nUsando tabs/espa√ßos e tamanhos de indenta√ß√£o diferentes, dificultando a leitura do c√≥digo; Usando encodings diferentes entre os arquivos, causando erros dif√≠ceis de serem encontrados (mostrando caracteres inv√°lidos) e quebrando testes automatizados. Nesse post eu vou mostrar como manter um padr√£o para todos que trabalham no c√≥digo, independente do editor utilizado, e em um pr√≥ximo post eu mostrarei como validar essas (e outras) regras em tempo de compila√ß√£o e na esteira de integra√ß√£o cont√≠nua.\nIntroduzindo o arquivo EditorConfig O arquivo EditorConfig √© usado por editores e IDEs para definir prefer√™ncias de formata√ß√£o do projeto. Sem ele, as IDEs e editores ir√£o usar suas configura√ß√µes padr√µes, causando diverg√™ncias entre arquivos editados neles.\nMuitos editores e IDEs suportam o arquivo EditorConfig por padr√£o, e outros suportam atrav√©s de plugins. Alguns exemplos:\nVisual Studio (Por padr√£o); JetBrains Rider (Por padr√£o); GitHub (Por padr√£o); VS Code (Plugin); Vim (Plugin); Emacs (Plugin); Sublime (Plugin); O arquivo tem o nome .editorconfig e √© um arquivo INI onde as se√ß√µes s√£o filtros por nome dos arquivos, por exemplo:\n[*.cs] para regras aplicadas a arquivos .cs; [scripts/**.js] para regras aplicadas a arquivos javascript dentro de uma pasta scripts e seus subdiret√≥rios; [{package.json}] para regras aplicadas apenas ao arquivo package.json. Mais detalhes aqui\nO arquivo EditorConfig pode ser colocado em qualquer diret√≥rio do projeto e sobrescrito por outro EditorConfig em diret√≥rios filhos, mas para ficar mais claro, costumo deix√°-lo na mesma pasta do arquivo da solution do .NET (.sln).\nAdicionando um EditorConfig ao seu projeto Para incluir um EditorConfig ao seu projeto, basta criar um arquivo com o nome .editorconfig no mesmo diret√≥rio da sua solution (arquivo .sln) com o conte√∫do abaixo.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # EditorConfig principal. root = true # Se√ß√µes para arquivos C# # As regras abaixo ser√£o aplicadas apenas aos arquivos .cs [*.cs] # Indenta√ß√£o e espa√ßamento indent_style = space indent_size = 4 # Prefer√™ncias de novas linhas end_of_line = crlf insert_final_newline = false trim_trailing_whitespace = true # Prefer√™ncias de encoding charset = utf-8 O arquivo define as seguintes regras:\nroot: Arquivos editorconfig em diret√≥rios superiores n√£o ser√£o lidos; indent_style: A indenta√ß√£o deve utilizar espa√ßo; indent_size: A indenta√ß√£o deve usar 4 caracteres de espa√ßo; end_of_line: Linhas devem terminar com os caracteres CR+LF; insert_final_newline: N√£o inserir automaticamente linhas em branco no final dos arquivos; trim_trailing_whitespace: Linhas vazias n√£o devem ter caracteres em branco; charset: Os arquivos devem ser salvos usando o formato UTF-8. Mais detalhes aqui.\n‚ö†Ô∏è O GIT permite alterar o final da linha para LF ao fazer pushes para o reposit√≥rio e alterar de volta para CRLF nos checkouts. Ent√£o, a configura√ß√£o end_of_line pode ser configurada como CRLF sem problemas. O GIT for Windows sugere essa configura√ß√£o como padr√£o durante a instala√ß√£o. Detalhes de como configurar aqui.\n‚ö†Ô∏è UTF-8 with BOM n√£o √© requerido e nem recomendado, de acordo com o padr√£o Unicode. Detalhes aqui.\n‚ÑπÔ∏è Em .NET, o arquivo EditorConfig tamb√©m pode ser usado para definir regras e severidades para os analyzers espec√≠ficos para a plataforma .NET. Em um pr√≥ximo post, vou mostrar como configurar essas regras.\nAplicando as novas regras de formata√ß√£o ao c√≥digo Quando n√≥s alteramos as regras de formata√ß√£o de um projeto existente, as altera√ß√µes n√£o s√£o aplicadas automaticamente. Precisamos executar manualmente a fun√ß√£o de formata√ß√£o autom√°tica da IDE.\nVisual Studio Primeiro, n√≥s precisamos incluir o fixer Format document no perfil do Code Cleanup.\n1 - Acesse Analyze \u0026gt; Code Cleanup \u0026gt; Configure Code Cleanup.\n2 - Inclua o fixer Format document no perfil que deseja executar ao salvar.\n3 - No menu, selecione Analyze \u0026gt; Code Cleanup \u0026gt; Run Code Cleanup (Yout Profile) on Solution.\n‚ö†Ô∏è A fun√ß√£o de formata√ß√£o do Visual Studio n√£o altera o encoding do arquivo. Para isso √© necess√°rio utilizar o dotnet-format ou outra ferramenta.\nVS Code O VS Code n√£o possui a funcionalidade de formatar todos os arquivos ao mesmo tempo. Para isso √© necess√°rio utilizar a extens√£o Format Files.\n1 - Instale a extens√£o Format Files.\n2 - Acesse View \u0026gt; Command Palette ou pressione Ctrl+Shift+P.\n3 - Selecione a op√ß√£o Start Format Files: Workspace ou a op√ß√£o Start Format Files: From Glob.\nJetBrains Rider Acesse Code \u0026gt; Reformat Code ou pressione Ctrl+Alt+Enter.\nFormat on save Quando criamos um arquivo EditorConfig, as IDEs ir√£o usar as configura√ß√µes dele para suas funcionalidades de formata√ß√£o autom√°tica.\nAqui eu mostro como habilitar a formata√ß√£o autom√°tica ao salvar os arquivos em algumas IDEs.\nFormatar ao salvar no Visual Studio O Visual Studio 2022 n√£o tem a funcionalidade de formatar ao salvar, por√©m, ele permite executar um perfil do Code Cleanup ao salvar. Dessa forma, podemos configurar um perfil do Code Cleanup para executar o fixer Format document e executar esse perfil ao salvar.\n‚ÑπÔ∏è Para o Visual Studio 2019, existe uma exten√ß√£o que habilita a mesma funcionalidade.\n1 - Configure seu perfil do Code Cleanup para executar o fixer Format document, como mostrado na se√ß√£o anterior deste post.\n2 - Acesse Tools \u0026gt; Options \u0026gt; Text Editor \u0026gt; Code Cleanup.\n3 - Marque a op√ß√£o Run Code Cleanup profile on Save e selecione o perfil do Code Cleanup para executar ao salvar.\nAgora o Visual Studio ir√° formatar seus arquivos toda vez que voc√™ salv√°-los.\nFormatar ao salvar no VS Code 1 - Acesse File \u0026gt; Preferences \u0026gt; Settings.\n2 - Acesse Text Editor \u0026gt; Formatting ou pesquise por editor.formatOnSave.\n3 - Marque a op√ß√£o Editor: Format On Save.\nFormatar ao salvar no JetBrains Rider 1 - Acesse File \u0026gt; Settings \u0026gt; Tools \u0026gt; Actions on Save.\n2 - Marque a op√ß√£o Reformat and Cleanup Code.\n3 - Selecione o perfil Reformat Code.\nRefer√™ncias e links https://editorconfig.org/ https://devblogs.microsoft.com/visualstudio/bringing-code-cleanup-on-save-to-visual-studio-2022-17-1-preview-2/ https://learn.microsoft.com/en-us/visualstudio/ide/create-portable-custom-editor-options?view=vs-2022 https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-format ","date":"2022-10-18T08:00:00-03:00","image":"https://blog.genezini.com/pt/p/definindo-regras-de-formatacao-no-.net-com-editorconfig/cover.pt.png","permalink":"https://blog.genezini.com/pt/p/definindo-regras-de-formatacao-no-.net-com-editorconfig/","title":"Definindo regras de formata√ß√£o no .NET com EditorConfig"},{"content":"Introdu√ß√£o Visual Studio Code √© a IDE mais utilizada de acordo com a Stack Overflow 2022\u0026rsquo;s Developer Survey e tem diversas extens√µes para nos ajudar com nossa produtividade. At√© desenvolvedores que n√£o usam o VS Code como sua IDE principal provavelmente usam ele para alguma parte de seu trabalho.\nIn this post I\u0026rsquo;ll show some of the extensions that I use to work, study and write this blog.\n1 - Project Manager Project Manager cria um √≠cone na barra lateral do VS Code e permite que voc√™ salve a pasta aberta para acesso r√°pido. Dessa forma voc√™ n√£o precisa procurar a pasta do projeto toda vez que for abrir; apenas abra o VS Code e selecione na lista de projetos.\nEu uso junto com a extens√£o Git Worktree que comentei no meu outro post. Eu salvo a minha branch padr√£o (por exemplo, a branch main) como um projecto e depois troco para a worktree na qual vou trabalhar.\nEla tamb√©m permite usar tags para organizar os projetos, ent√£o eu marco os diferentes componentes de um sistema com o nome do sistema.\nDownload\n2 - Compare Folders Compare Folders mostra a diferen√ßa entre o conte√∫do de duas pastas, al√©m de mostrar uma compara√ß√£o lado a lado edit√°vel dos arquivos. Ela tamb√©m permite copiar arquivos presentes em apenas uma pasta para a outra pasta sendo comparada.\nEu uso bastante para comparar duas branches ou duas vers√µes de um reposit√≥rio.\nDownload\n3 - Path Intellisense Path Intellisense mostra um menu para sele√ß√£o do caminho dos arquivos dentro do c√≥digo. Ela funciona com HTML, CSS, Typescript, Javascript e outros tipos de arquivo.\nDownload\n4 - Draw.io Integration Draw.io √© uma ferramenta gratuita e open source para desenho de diagramas, wireframes, etc.\nEssa extens√£o permite abrir e editar arquivos .drawio por dentro do VS Code.\nDownload\n5 - Excalidraw Excalidraw √© uma ferramenta de lousa virtual que permite criar diagramas com um visual de desenho a m√£o. Assim como a extens√£o do Draw.io, essa extens√£o permite abrir e editar arquivos .excalidraw por dentro do VS Code.\nDownload\n6 - Docker for Visual Studio Code Essa extens√£o desenvolvida pela Microsoft permite voc√™ gerenciar imagens, containers, redes e volumes Docker. √â uma √≥tima alternativa ao Dashboard do Docker Desktop, que agora √© pago para uso comercial.\n√â muito √∫til para conectar no shell de containers em execu√ß√£o ou consultar logs com apenas um click. Tamb√©m permite abrir e editar arquivos dentro de um container.\nDownload\n7 - vs-openapi-designer Essa extens√£o renderiza o documento OpenAPI YAML/JSON em um painel lateral para confer√™ncia. Ela ajuda muito na valida√ß√£o de contratos complexos, que cont√©m diversos arquivos na sua composi√ß√£o.\nDownload\n8 - Terraform A extens√£o Terraform adiciona suporte sint√°tico para os arquivos .tf, com diversos snippets, al√©m de intellisense.\nDownload\n9 - VSCode Great Icons Um pacote de √≠cones muito bem feito para o VS Code. Eu gosto desse pacote pois ele usa apenas duas varia√ß√µes para os √≠cones de pastas, deixando o explorador de arquivos mais clean do que com outros pacotes de √≠cones, que acabam deixando a visualiza√ß√£o confusa.\nDownload\n10 - Color Highlight Color Highlight mostra uma pr√©via da cor no seus arquivos CSS e HTML.\nDownload\n11 - Import Cost Essa extens√£o mostra informa√ß√µes sobre o tamanho do pacote sendo importado ao final da linha. Ela usa o webpack para detectar o tamanho do pacote e funciona com import e require().\nDownload\n","date":"2022-10-11T07:00:00-03:00","image":"https://blog.genezini.com/pt/p/extensoes-do-vs-code-que-vale-a-pena-testar/cover.pt.png","permalink":"https://blog.genezini.com/pt/p/extensoes-do-vs-code-que-vale-a-pena-testar/","title":"Extens√µes do VS Code que vale a pena testar"},{"content":"Introdu√ß√£o Quando estamos trabalhando em um projeto, muitas vezes precisamos trocar para uma outra branch para ajudar um colega, corrigir algum bug, ou trabalhar em uma outra funcionalidade (por troca de prioridade ou devido a algum impedimento).\nQuando isso acontece, temos algumas op√ß√µes:\nClonar novamente o projeto em outra pasta: Essa era a op√ß√£o que eu usava at√© pouco tempo atr√°s, mas se voc√™ estiver trabalhando com um projeto grande, pode levar um tempo para fazer download do reposit√≥rio remoto, al√©m de usar mais espa√ßo em disco, pois vai resultar em outra c√≥pia do reposit√≥rio local para cada branch.\nFazer stash ou commit das altera√ß√µes e checkout da outra branch: Essa op√ß√£o √© ok, mas √© mais trabalhosa e n√£o permite ter mais de uma branch em paralelo;\nAdicionar uma nova working tree: Essa √© a op√ß√£o que prefiro porque posso ter um √∫nico reposit√≥rio local compartilhado entre as branches.\nNesse post, vou mostrar como utilizar o working trees para trocar branches de forma mais f√°cil.\nComo um reposit√≥rio Git funciona Quando usamos o comando git clone, o Git cria duas coisas no destino: uma working tree e um reposit√≥rio local, c√≥pia do reposit√≥rio remoto (pasta .git dentro da pasta da working tree).\n‚ÑπÔ∏è git clone --bare clona apenas o reposit√≥rio no destino, sem a working tree.\nReposit√≥rio O reposit√≥rio Git √© um diret√≥rio estruturado que armazena os objetos, branches e outros componentes utilizados pelo Git para controlar as vers√µes dos nossos arquivos.\nWorking tree Uma working tree √© onde os nossos arquivos propriamente ditos ficam armazenados. Quando usamos git checkout, o Git troca todos os arquivos na working tree para refletir os arquivos da branch.\nExemplo git clone https://github.com/dgenezini/MeuProjeto.git MeuProjeto Dentro do reposit√≥rio ficam v√°rios arquivos e pastas, mas para o escopo desse post, esses s√£o os mais importantes:\nobjects = Diret√≥rio onde s√£o armazenados os blobs (arquivos), trees (diret√≥rios), e commits; refs = Diret√≥rio onde s√£o armazenados ponteiros para os commits que s√£o os heads de cada branch no reposit√≥rio; HEAD = Arquivo apontando para a branch ou tag da working tree; index = Arquivo usado para controlar as altera√ß√µes pendentes da working tree. Por que usar Git Worktree? Usando o comando git worktree, podemos criar m√∫ltiplas working trees apontando para o mesmo reposit√≥rio local, assim compartilhando a maioria dos componentes entre as working trees.\nEm vez de um diret√≥rio .git, as working trees adicionais tem um arquivo .git apontando para uma pasta dentro do reposit√≥rio local.\nDentro da pasta da working tree, temos os componentes do Git que n√£o s√£o compartilhados com outras working trees. Observe que a maioria do reposit√≥rio, incluindo a pasta objects (com os arquivos, diret√≥rios e commits), √© compartilhada.\nEsses s√£o os principais componentes em uma pasta de working tree:\nHEAD = Arquivo apontando para a branch da working tree; index = Arquivo usado para controlar as altera√ß√µes pendentes da working tree; commondir = Arquivo apontando para o reposit√≥rio local. Usando Git Worktree Eu gosto de ter todas as working trees como sub-pastas, ent√£o eu come√ßo criando uma pasta com o nome do meu reposit√≥rio e clonando a branch principal para uma pasta com o nome dela (no meu caso, main).\nmkdir MeuProjeto \u0026amp;\u0026amp; cd MeuProjeto git clone https://github.com/dgenezini/MeuProjeto.git main Esse √© a estrutura que teremos:\nMeuProjeto/ \u0026lt;-- Nome do reposit√≥rio ‚îî‚îÄ‚îÄ main \u0026lt;-- Nome da branch ‚îú‚îÄ‚îÄ .git \u0026lt;-- Reposit√≥rio local ‚îî‚îÄ‚îÄ README.md ‚ÑπÔ∏è Algumas pessoas usam git clone --bare para criar o reposit√≥rio local sem uma working tree, mas a op√ß√£o --bare n√£o mapeia as branches locais para suas origens remotas, ent√£o eu prefiro clonar uma branch padr√£o (nesse exemplo, a branch main), porque dessa forma eu n√£o preciso mapear manualmente a origem das branches para cada working tree criada.\nCriando uma working tree Dentro do diret√≥rio main, use o comando git worktree add:\ngit worktree add [path] [branch] Exemplo:\ncd main git worktree add ../featureA featureA Esse √© o resultado:\nMeuProjeto/ \u0026lt;-- Nome do reposit√≥rio ‚îú‚îÄ‚îÄ featureA \u0026lt;-- Nome da branch ‚îÇ¬†‚îú‚îÄ‚îÄ .git \u0026lt;-- Arquivo apontando para ../main/.git ‚îÇ¬†‚îî‚îÄ‚îÄ README.md ‚îî‚îÄ‚îÄ main \u0026lt;-- Nome da branch ‚îú‚îÄ‚îÄ .git \u0026lt;-- Reposit√≥rio local ‚îî‚îÄ‚îÄ README.md ‚ÑπÔ∏è Voc√™ pode usar o comando git worktree add e outros comando do Git dentro de qualquer diret√≥rio de working tree.\n‚ö†Ô∏è Se estiver usando windows, troque a barra no caminho de ../featureA para ..\\featureA.\nTrocando para uma working tree Apenas mude o diret√≥rio onde est√° trabalhando:\ncd ../featureA Removendo uma working tree Dentro do diret√≥rio main, use o comando git worktree remove:\ngit worktree remove [branch] Exemplo:\ngit worktree remove featureA ou exclua a pasta da working tree (nesse exemplo, featureA), e use o comando git worktree prune para remover as working trees que n√£o existem mais.\nExtens√£o Git Worktrees para Visual Studio Code Git Worktrees √© uma extens√£o gratuita para Visual Studio Code que nos ajuda a trabalhar com working trees.\nCriando uma working tree Abra a paleta de comandos (Ctrl+Shift+P), procure por worktree add\nTrocando para uma working tree Abra a paleta de comandos (Ctrl+Shift+P), procure por worktree list e selecione Git Worktree: List.\nSelecione a branch onde quer trabalhar e o VS Code abrir√° uma nova janela com a working tree selecionada.\nRemovendo uma working tree Abra a paleta de comandos (Ctrl+Shift+P), procure por worktree remove e selecione Git Worktree: Remove.\nSelecione a branch que quer remover.\n‚ö†Ô∏è Voc√™ n√£o pode remover a working tree que est√° aberta no VS Code.\nTrocando para uma working tree pelo Visual Studio 2022 O Visual Studio √© a minha IDE favorita para trabalhar com .NET, ent√£o √© importante que eu consiga trocar de forma f√°cil entre working trees atrav√©s dele.\nUma vez que a working tree foi aberta pela primeira vez no Visual Studio, ele ir√° rastrear ela como um reposit√≥rio na barra de status. Para trocar de working tree, basta trocar o reposit√≥rio:\nRefer√™ncias e links https://git-scm.com/docs/git-clone https://git-scm.com/docs/git-worktree https://marketplace.visualstudio.com/items?itemName=GitWorktrees.git-worktrees ","date":"2022-09-30T09:35:00-03:00","image":"https://blog.genezini.com/pt/p/trabalhando-em-m%C3%BAltiplas-branches-git-paralelamente/cover.pt.png","permalink":"https://blog.genezini.com/pt/p/trabalhando-em-m%C3%BAltiplas-branches-git-paralelamente/","title":"Trabalhando em m√∫ltiplas branches Git paralelamente"},{"content":"Introdu√ß√£o Embora n√£o exista um consenso sobre o escopo de um teste de integra√ß√£o, Martin Fowler define testes de integra√ß√£o restritos (Narrow), nos quais a integra√ß√£o entre os sistemas √© testada usando substitutos (Mocks), e testes de integra√ß√£o amplos (Broad), que se comunicam com APIs reais.\nNesse post, explicarei como criar mocks para APIs HTTP em testes de integra√ß√£o restritos usando a biblioteca WireMock.Net.\nO que \u0026ldquo;mockar\u0026rdquo;? Vladimir Khorikov tem um conceito de depend√™ncias gerenciadas e n√£o gerenciadas, que considero complementar ao conceito de Martin Fowler, para escolhermos o que deve e o que n√£o deve ser \u0026ldquo;mockado\u0026rdquo;.\nSegundo Vladimir, depend√™ncias gerenciadas s√£o sistemas externos controlados por n√≥s e acessados apenas pela nossa aplica√ß√£o (por exemplo, um banco de dados). Por outro lado, depend√™ncias n√£o gerenciadas s√£o sistemas externos n√£o controlados por n√≥s ou que s√£o acessados tamb√©m por outras aplica√ß√µes (como uma API de terceiros e um message broker).\nVladimir defende que devemos fazer nossos testes de integra√ß√£o consumindo depend√™ncias gerenciadas e \u0026ldquo;mockando\u0026rdquo; depend√™ncias n√£o gerenciadas. Eu acredito que essa defini√ß√£o serve mais como um norte do que como uma regra. Por exemplo, em um cen√°rio onde nosso sistema posta mensagens em um message broker para outro sistema ler, ou seja, o message broker √© uma depend√™ncia n√£o gerenciada, podemos testar a integra√ß√£o com o message broker para validar que a mensagem est√° sendo postada no formato correto (contrato definido). Isso pode ser valioso para validar que atualiza√ß√µes na biblioteca usada para se comunicar com o message broker n√£o modificou o formato e o conte√∫do das mensagens.\nPor que usar mocks? O intuito dos testes de integra√ß√£o restritos √© testar se seus componentes, testados individualmente atrav√©s de testes de unidade, funcionam corretamente de forma integrada entre si. Quando consumimos uma API, seguimos um protocolo e confiamos em um contrato de comunica√ß√£o, isto √©, que ela vai aceitar uma entrada X e retornar uma resposta Y.\nDessa forma, o funcionamento da API externa n√£o est√° no escopo dos testes integrados.\nIsso n√£o exclui a necessidade de realizar testes funcionais; apenas diminui a quantidade necess√°ria desses testes, que, em geral, s√£o mais custosos de serem executados.\nRestringindo os testes de integra√ß√£o apenas ao nosso sistema, temos alguns benef√≠cios:\nVelocidade nos testes, pois retiramos a lat√™ncia da rede; N√£o depend√™ncia de dados para teste em sistemas externos; Menor fragilidade dos testes, que podem quebrar em caso de instabilidade ou de dados que foram alterados nos sistemas externos, dificultando a interpreta√ß√£o dos resultados; Maior confian√ßa nos resultados dos testes. Usando WireMock.Net Nesse exemplo, constru√≠ uma API que usa o servi√ßo Pok√©API para buscar os dados de um Pok√©mon e retornar os dados para o cliente da nossa API.\nController O controller √© simples e usa a biblioteca Refit para abstrair a chamada da API e, por simplicidade, retorna o mesmo objeto.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 using Microsoft.AspNetCore.Mvc; using Refit; namespace PokemonInfoAPI.Controllers { [ApiController] [Route(\u0026#34;[controller]\u0026#34;)] public class PokemonInfoController : ControllerBase { private readonly IConfiguration _configuration; public PokemonInfoController(IConfiguration configuration) { _configuration = configuration; } [HttpGet(\u0026#34;{pokemonName}\u0026#34;)] public async Task\u0026lt;ActionResult\u0026lt;PokemonInfo\u0026gt;\u0026gt; GetAsync(string pokemonName) { try { var pokeApi = RestService.For\u0026lt;IPokeApi\u0026gt;(_configuration[\u0026#34;PokeApiBaseUrl\u0026#34;]); return Ok(await pokeApi.GetPokemonInfo(pokemonName)); } catch (ApiException ex) { if (ex.StatusCode == System.Net.HttpStatusCode.NotFound) { return NotFound(); } return StatusCode(500); } } } } Teste de integra√ß√£o padr√£o Come√ßamos com um teste de integra√ß√£o padr√£o, usando a classe WebApplicationFactory do ASP.NET Core.\nO teste cria uma inst√¢ncia da nossa aplica√ß√£o e faz uma chamada ao endpoint /pokemoninfo passando o par√¢metro charmander. A chamada ao endpoint faz nossa aplica√ß√£o chamar a API Pok√©API.\nüí° Voc√™ pode usar qualquer classe do projeto da API para instanciar o WebApplicationFactory nos seus testes. Se estiver usando statements na sua aplica√ß√£o, voc√™ pode usar a classe do controller. Por exemplo, WebApplicationFactory\u0026lt;PokemonInfoController\u0026gt;.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 using FluentAssertions; using Microsoft.AspNetCore.Mvc.Testing; using System.Net; using System.Text.Json; namespace PokemonInfoAPI.IntegrationTests { public class PokemonInfoTests: IClassFixture\u0026lt;WebApplicationFactory\u0026lt;Program\u0026gt;\u0026gt; { private readonly WebApplicationFactory\u0026lt;Program\u0026gt; _factory; public PokemonInfoTests(WebApplicationFactory\u0026lt;Program\u0026gt; factory) { _factory = factory; } [Fact] public async Task Get_Existing_Pokemon_Returns_200() { //Arrange var HttpClient = Factory.CreateClient(); //Act var HttpResponse = await HttpClient.GetAsync(\u0026#34;/pokemoninfo/charmander\u0026#34;); //Assert HttpResponse.StatusCode.Should().Be(HttpStatusCode.OK); var ResponseJson = await HttpResponse.Content.ReadAsStringAsync(); var PokemonInfo = JsonSerializer.Deserialize\u0026lt;PokemonInfo\u0026gt;(ResponseJson); PokemonInfo.Should().BeEquivalentTo(ResponseObj); } } } Criando um mock para o sistema externo Pok√©API O WireMock.Net √© uma biblioteca que possibilita a cria√ß√£o de mocks para APIs HTTP. Ele cria um servidor web no mesmo processo dos nossos testes e exp√µe uma URL para ser acessada pela nossa aplica√ß√£o.\nUsando o WireMock.Net e o WebApplicationFactory teremos o seguinte cen√°rio:\nPrimeiro, instalo o pacote Nuget WireMock.Net no projeto de testes.\nUtilizando o Package Manager pelo Visual Studio Install-Package WireMock.Net Ou\nUtilizando o .NET CLI pela linha de comando dotnet add package WireMock.Net Iniciando o servidor do WireMock.Net Para iniciar o servidor do WireMock.Net, chamo o m√©todo Start da classe WireMockServer, que retorna um objeto com os dados do servidor.\n1 var WireMockSvr = WireMockServer.Start(); Sobrescrevendo as configura√ß√µes da nossa aplica√ß√£o Com o servidor iniciado, sobrescrevo o par√¢metro PokeApiBaseUrl, que cont√©m a URL do Pok√©API, nas configura√ß√µes da minha aplica√ß√£o usando o m√©todo WithWebHostBuilder do WebApplicationFactory:\n1 2 3 4 5 6 var HttpClient = _factory .WithWebHostBuilder(builder =\u0026gt; { builder.UseSetting(\u0026#34;PokeApiBaseUrl\u0026#34;, WireMockSvr.Url); }) .CreateClient(); Criando o mock para o endpoint /pokemon Em seguida, crio o mock para o endpoint /pokemon recebendo o par√¢metro charmander.\nNo exemplo abaixo, estou usando o AutoFixture para gerar um objeto com valores aleat√≥rios, que ser√° retornado pelo mock.\n‚ÑπÔ∏è Usar um objeto me possibilita comparar o retorno do meu sistema com esse objeto, mas tamb√©m √© poss√≠vel configurar o retorno a partir de um arquivo, utilizando WithBodyFromFile.\nTamb√©m configuro os Headers que ser√£o retornados e o status HTTP.\n1 2 3 4 5 6 7 8 9 10 11 12 13 Fixture fixture = new Fixture(); var ResponseObj = fixture.Create\u0026lt;PokemonInfo\u0026gt;(); var ResponseObjJson = JsonSerializer.Serialize(ResponseObj); WireMockSvr .Given(Request.Create() .WithPath(\u0026#34;/pokemon/charmander\u0026#34;) .UsingGet()) .RespondWith(Response.Create() .WithBody(ResponseObjJson) .WithHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .WithStatusCode(HttpStatusCode.OK)); Feito isso, minha aplica√ß√£o instanciada dentro dos testes j√° estar√° consumindo o mock, em vez da API real.\nC√≥digo completo do teste 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 [Fact] public async Task Get_Existing_Pokemon_Returns_200() { //Arrange var WireMockSvr = WireMockServer.Start(); var HttpClient = _factory .WithWebHostBuilder(builder =\u0026gt; { builder.UseSetting(\u0026#34;PokeApiBaseUrl\u0026#34;, WireMockSvr.Url); }) .CreateClient(); Fixture fixture = new Fixture(); var ResponseObj = fixture.Create\u0026lt;PokemonInfo\u0026gt;(); var ResponseObjJson = JsonSerializer.Serialize(ResponseObj); WireMockSvr .Given(Request.Create() .WithPath(\u0026#34;/pokemon/charmander\u0026#34;) .UsingGet()) .RespondWith(Response.Create() .WithBody(ResponseObjJson) .WithHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .WithStatusCode(HttpStatusCode.OK)); //Act var HttpResponse = await HttpClient.GetAsync(\u0026#34;/pokemoninfo/charmander\u0026#34;); //Assert HttpResponse.StatusCode.Should().Be(HttpStatusCode.OK); var ResponseJson = await HttpResponse.Content.ReadAsStringAsync(); var PokemonInfo = JsonSerializer.Deserialize\u0026lt;PokemonInfo\u0026gt;(ResponseJson); PokemonInfo.Should().BeEquivalentTo(ResponseObj); WireMockSvr.Stop(); } Exemplo simulando um cen√°rio de n√£o sucesso Pelo contrato da API, sabemos que ela retorna o status 404 (Not Found) quando recebe um pok√©mon inv√°lido como par√¢metro, ent√£o criei um mock que retorna esse status ao receber o par√¢metro picapau e valido que o retorno da minha aplica√ß√£o est√° correto.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 [Fact] public async Task Get_NotExisting_Pokemon_Returns_404() { //Arrange var WireMockSvr = WireMockServer.Start(); var Factory = _factory.WithWebHostBuilder(builder =\u0026gt; { builder.UseSetting(\u0026#34;PokeApiBaseUrl\u0026#34;, WireMockSvr.Url); }); var HttpClient = Factory.CreateClient(); Fixture fixture = new Fixture(); WireMockSvr .Given(Request.Create() .WithPath(\u0026#34;/pokemon/picapau\u0026#34;) .UsingGet()) .RespondWith(Response.Create() .WithHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .WithStatusCode(HttpStatusCode.NotFound)); //Act var HttpResponse = await HttpClient .GetAsync(\u0026#34;/pokemoninfo/picapau\u0026#34;); //Assert HttpResponse.StatusCode.Should().Be(HttpStatusCode.NotFound); WireMockSvr.Stop(); } Fonte completo https://github.com/dgenezini/PokemonInfoAPIWireMockTests\nRefer√™ncias e links https://martinfowler.com/bliki/IntegrationTest.html https://khorikov.org/posts/2021-11-29-unmanaged-dependencies-explained/ https://github.com/WireMock-Net/WireMock.Net https://github.com/reactiveui/refit https://github.com/AutoFixture/AutoFixture https://github.com/fluentassertions/fluentassertions ","date":"2022-09-21T08:00:00-03:00","image":"https://blog.genezini.com/p/integration-tests-without-api-dependencies-with-asp.net-core-and-wiremock.net/cover.jpg","permalink":"https://blog.genezini.com/pt/p/testes-de-integracao-com-aspnet-core-e-wiremocknet/","title":"Testes de integra√ß√£o sem depend√™ncias de APIs com ASP.NET Core e WireMock.Net"}]