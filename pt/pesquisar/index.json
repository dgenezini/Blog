[{"content":"Introduction Quando trabalhamos com outras pessoas, usando editores e IDEs variadas, é comum que haja diferenças nas configurações dos mesmo, fazendo com que se perca consistência no estilo de formatação do código. Por exemplo:\nUsando tabs/espaços e tamanhos de indentação diferentes, dificultando a leitura do código; Usando encodings diferentes entre os arquivos, causando erros difíceis de serem encontrados (mostrando caracteres inválidos) e quebrando testes automatizados. Nesse post eu vou mostrar como manter um padrão para todos que trabalham no código, independente do editor utilizado, e em um próximo post eu mostrarei como validar essas (e outras) regras em tempo de compilação e na esteira de integração contínua.\nIntroduzindo o arquivo EditorConfig O arquivo EditorConfig é usado por editores e IDEs para definir preferências de formatação do projeto. Sem ele, as IDEs e editores irão usar suas configurações padrões, causando divergências entre arquivos editados neles.\nMuitos editores e IDEs suportam o arquivo EditorConfig por padrão, e outros suportam através de plugins. Alguns exemplos:\nVisual Studio (Por padrão); JetBrains Rider (Por padrão); GitHub (Por padrão); VS Code (Plugin); Vim (Plugin); Emacs (Plugin); Sublime (Plugin); O arquivo tem o nome .editorconfig e é um arquivo INI onde as seções são filtros por nome dos arquivos, por exemplo:\n[*.cs] para regras aplicadas a arquivos .cs; [scripts/**.js] para regras aplicadas a arquivos javascript dentro de uma pasta scripts e seus subdiretórios; [{package.json}] para regras aplicadas apenas ao arquivo package.json. Mais detalhes aqui\nO arquivo EditorConfig pode ser colocado em qualquer diretório do projeto e sobrescrito por outro EditorConfig em diretórios filhos, mas para ficar mais claro, costumo deixá-lo na mesma pasta do arquivo da solution do .NET (.sln).\nAdicionando um EditorConfig ao seu projeto Para incluir um EditorConfig ao seu projeto, basta criar um arquivo com o nome .editorconfig no mesmo diretório da sua solution (arquivo .sln) com o conteúdo abaixo.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # EditorConfig principal. root = true # Seções para arquivos C# # As regras abaixo serão aplicadas apenas aos arquivos .cs [*.cs] # Indentação e espaçamento indent_style = space indent_size = 4 # Preferências de novas linhas end_of_line = crlf insert_final_newline = false trim_trailing_whitespace = true # Preferências de encoding charset = utf-8 O arquivo define as seguintes regras:\nroot: Arquivos editorconfig em diretórios superiores não serão lidos; indent_style: A indentação deve utilizar espaço; indent_size: A indentação deve usar 4 caracteres de espaço; end_of_line: Linhas devem terminar com os caracteres CR+LF; insert_final_newline: Não inserir automaticamente linhas em branco no final dos arquivos; trim_trailing_whitespace: Linhas vazias não devem ter caracteres em branco; charset: Os arquivos devem ser salvos usando o formato UTF-8. Mais detalhes aqui.\n⚠️ O GIT permite alterar o final da linha para LF ao fazer pushes para o repositório e alterar de volta para CRLF nos checkouts. Então, a configuração end_of_line pode ser configurada como CRLF sem problemas. O GIT for Windows sugere essa configuração como padrão durante a instalação. Detalhes de como configurar aqui.\n⚠️ UTF-8 with BOM não é requerido e nem recomendado, de acordo com o padrão Unicode. Detalhes aqui.\nℹ️ Em .NET, o arquivo EditorConfig também pode ser usado para definir regras e severidades para os analyzers específicos para a plataforma .NET. Em um próximo post, vou mostrar como configurar essas regras.\nAplicando as novas regras de formatação ao código Quando nós alteramos as regras de formatação de um projeto existente, as alterações não são aplicadas automaticamente. Precisamos executar manualmente a função de formatação automática da IDE.\nVisual Studio Primeiro, nós precisamos incluir o fixer Format document no perfil do Code Cleanup.\n1 - Acesse Analyze \u0026gt; Code Cleanup \u0026gt; Configure Code Cleanup.\n2 - Inclua o fixer Format document no perfil que deseja executar ao salvar.\n3 - No menu, selecione Analyze \u0026gt; Code Cleanup \u0026gt; Run Code Cleanup (Yout Profile) on Solution.\n⚠️ A função de formatação do Visual Studio não altera o encoding do arquivo. Para isso é necessário utilizar o dotnet-format ou outra ferramenta.\nVS Code O VS Code não possui a funcionalidade de formatar todos os arquivos ao mesmo tempo. Para isso é necessário utilizar a extensão Format Files.\n1 - Instale a extensão Format Files.\n2 - Acesse View \u0026gt; Command Palette ou pressione Ctrl+Shift+P.\n3 - Selecione a opção Start Format Files: Workspace ou a opção Start Format Files: From Glob.\nJetBrains Rider Acesse Code \u0026gt; Reformat Code ou pressione Ctrl+Alt+Enter.\nFormat on save Quando criamos um arquivo EditorConfig, as IDEs irão usar as configurações dele para suas funcionalidades de formatação automática.\nAqui eu mostro como habilitar a formatação automática ao salvar os arquivos em algumas IDEs.\nFormatar ao salvar no Visual Studio O Visual Studio 2022 não tem a funcionalidade de formatar ao salvar, porém, ele permite executar um perfil do Code Cleanup ao salvar. Dessa forma, podemos configurar um perfil do Code Cleanup para executar o fixer Format document e executar esse perfil ao salvar.\nℹ️ Para o Visual Studio 2019, existe uma extenção que habilita a mesma funcionalidade.\n1 - Configure seu perfil do Code Cleanup para executar o fixer Format document, como mostrado na seção anterior deste post.\n2 - Acesse Tools \u0026gt; Options \u0026gt; Text Editor \u0026gt; Code Cleanup.\n3 - Marque a opção Run Code Cleanup profile on Save e selecione o perfil do Code Cleanup para executar ao salvar.\nAgora o Visual Studio irá formatar seus arquivos toda vez que você salvá-los.\nFormatar ao salvar no VS Code 1 - Acesse File \u0026gt; Preferences \u0026gt; Settings.\n2 - Acesse Text Editor \u0026gt; Formatting ou pesquise por editor.formatOnSave.\n3 - Marque a opção Editor: Format On Save.\nFormatar ao salvar no JetBrains Rider 1 - Acesse File \u0026gt; Settings \u0026gt; Tools \u0026gt; Actions on Save.\n2 - Marque a opção Reformat and Cleanup Code.\n3 - Selecione o perfil Reformat Code.\nReferências e links https://editorconfig.org/ https://devblogs.microsoft.com/visualstudio/bringing-code-cleanup-on-save-to-visual-studio-2022-17-1-preview-2/ https://learn.microsoft.com/en-us/visualstudio/ide/create-portable-custom-editor-options?view=vs-2022 https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-format ","date":"2022-10-18T08:00:00-03:00","image":"https://blog.genezini.com/pt/p/definindo-regras-de-formatacao-no-.net-com-editorconfig/cover.pt.png","permalink":"https://blog.genezini.com/pt/p/definindo-regras-de-formatacao-no-.net-com-editorconfig/","title":"Definindo regras de formatação no .NET com EditorConfig"},{"content":"Introdução Visual Studio Code é a IDE mais utilizada de acordo com a Stack Overflow 2022\u0026rsquo;s Developer Survey e tem diversas extensões para nos ajudar com nossa produtividade. Até desenvolvedores que não usam o VS Code como sua IDE principal provavelmente usam ele para alguma parte de seu trabalho.\nIn this post I\u0026rsquo;ll show some of the extensions that I use to work, study and write this blog.\n1 - Project Manager Project Manager cria um ícone na barra lateral do VS Code e permite que você salve a pasta aberta para acesso rápido. Dessa forma você não precisa procurar a pasta do projeto toda vez que for abrir; apenas abra o VS Code e selecione na lista de projetos.\nEu uso junto com a extensão Git Worktree que comentei no meu outro post. Eu salvo a minha branch padrão (por exemplo, a branch main) como um projecto e depois troco para a worktree na qual vou trabalhar.\nEla também permite usar tags para organizar os projetos, então eu marco os diferentes componentes de um sistema com o nome do sistema.\nDownload\n2 - Compare Folders Compare Folders mostra a diferença entre o conteúdo de duas pastas, além de mostrar uma comparação lado a lado editável dos arquivos. Ela também permite copiar arquivos presentes em apenas uma pasta para a outra pasta sendo comparada.\nEu uso bastante para comparar duas branches ou duas versões de um repositório.\nDownload\n3 - Path Intellisense Path Intellisense mostra um menu para seleção do caminho dos arquivos dentro do código. Ela funciona com HTML, CSS, Typescript, Javascript e outros tipos de arquivo.\nDownload\n4 - Draw.io Integration Draw.io é uma ferramenta gratuita e open source para desenho de diagramas, wireframes, etc.\nEssa extensão permite abrir e editar arquivos .drawio por dentro do VS Code.\nDownload\n5 - Excalidraw Excalidraw é uma ferramenta de lousa virtual que permite criar diagramas com um visual de desenho a mão. Assim como a extensão do Draw.io, essa extensão permite abrir e editar arquivos .excalidraw por dentro do VS Code.\nDownload\n6 - Docker for Visual Studio Code Essa extensão desenvolvida pela Microsoft permite você gerenciar imagens, containers, redes e volumes Docker. É uma ótima alternativa ao Dashboard do Docker Desktop, que agora é pago para uso comercial.\nÉ muito útil para conectar no shell de containers em execução ou consultar logs com apenas um click. Também permite abrir e editar arquivos dentro de um container.\nDownload\n7 - vs-openapi-designer Essa extensão renderiza o documento OpenAPI YAML/JSON em um painel lateral para conferência. Ela ajuda muito na validação de contratos complexos, que contém diversos arquivos na sua composição.\nDownload\n8 - Terraform A extensão Terraform adiciona suporte sintático para os arquivos .tf, com diversos snippets, além de intellisense.\nDownload\n9 - VSCode Great Icons Um pacote de ícones muito bem feito para o VS Code. Eu gosto desse pacote pois ele usa apenas duas variações para os ícones de pastas, deixando o explorador de arquivos mais clean do que com outros pacotes de ícones, que acabam deixando a visualização confusa.\nDownload\n10 - Color Highlight Color Highlight mostra uma prévia da cor no seus arquivos CSS e HTML.\nDownload\n11 - Import Cost Essa extensão mostra informações sobre o tamanho do pacote sendo importado ao final da linha. Ela usa o webpack para detectar o tamanho do pacote e funciona com import e require().\nDownload\n","date":"2022-10-11T07:00:00-03:00","image":"https://blog.genezini.com/pt/p/extensoes-do-vs-code-que-vale-a-pena-testar/cover.pt.png","permalink":"https://blog.genezini.com/pt/p/extensoes-do-vs-code-que-vale-a-pena-testar/","title":"Extensões do VS Code que vale a pena testar"},{"content":"Introdução Quando estamos trabalhando em um projeto, muitas vezes precisamos trocar para uma outra branch para ajudar um colega, corrigir algum bug, ou trabalhar em uma outra funcionalidade (por troca de prioridade ou devido a algum impedimento).\nQuando isso acontece, temos algumas opções:\nClonar novamente o projeto em outra pasta: Essa era a opção que eu usava até pouco tempo atrás, mas se você estiver trabalhando com um projeto grande, pode levar um tempo para fazer download do repositório remoto, além de usar mais espaço em disco, pois vai resultar em outra cópia do repositório local para cada branch.\nFazer stash ou commit das alterações e checkout da outra branch: Essa opção é ok, mas é mais trabalhosa e não permite ter mais de uma branch em paralelo;\nAdicionar uma nova working tree: Essa é a opção que prefiro porque posso ter um único repositório local compartilhado entre as branches.\nNesse post, vou mostrar como utilizar o working trees para trocar branches de forma mais fácil.\nComo um repositório GIT funciona Quando usamos o comando git clone, o GIT cria duas coisas no destino: uma working tree e um repositório local, cópia do repositório remoto (pasta .git dentro da pasta da working tree).\nℹ️ git clone --bare clona apenas o repositório no destino, sem a working tree.\nRepositório O repositório GIT é um diretório estruturado que armazena os objetos, branches e outros componentes utilizados pelo GIT para controlar as versões dos nossos arquivos.\nWorking tree Uma working tree é onde os nossos arquivos propriamente ditos ficam armazenados. Quando usamos git checkout, o GIT troca todos os arquivos na working tree para refletir os arquivos da branch.\nExemplo 1 git clone https://github.com/dgenezini/MeuProjeto.git MeuProjeto Dentro do repositório ficam vários arquivos e pastas, mas para o escopo desse post, esses são os mais importantes:\nobjects = Diretório onde são armazenados os blobs (arquivos), trees (diretórios), e commits; refs = Diretório onde são armazenados ponteiros para os commits que são os heads de cada branch no repositório; HEAD = Arquivo apontando para a branch ou tag da working tree; index = Arquivo usado para controlar as alterações pendentes da working tree. Por que usar GIT Worktree? Usando o comando git worktree, podemos criar múltiplas working trees apontando para o mesmo repositório local, assim compartilhando a maioria dos componentes entre as working trees.\nEm vez de um diretório .git, as working trees adicionais tem um arquivo .git apontando para uma pasta dentro do repositório local.\nDentro da pasta da working tree, temos os componentes do GIT que não são compartilhados com outras working trees. Observe que a maioria do repositório, incluindo a pasta objects (com os arquivos, diretórios e commits), é compartilhada.\nEsses são os principais componentes em uma pasta de working tree:\nHEAD = Arquivo apontando para a branch da working tree; index = Arquivo usado para controlar as alterações pendentes da working tree; commondir = Arquivo apontando para o repositório local. Usando GIT Worktree Eu gosto de ter todas as working trees como sub-pastas, então eu começo criando uma pasta com o nome do meu repositório e clonando a branch principal para uma pasta com o nome dela (no meu caso, main).\n1 2 mkdir MeuProjeto \u0026amp;\u0026amp; cd MeuProjeto git clone https://github.com/dgenezini/MeuProjeto.git main Esse é a estrutura que teremos:\n1 2 3 4 MeuProjeto/ \u0026lt;-- Nome do repositório └── main \u0026lt;-- Nome da branch ├── .git \u0026lt;-- Repositório local └── README.md ℹ️ Algumas pessoas usam git clone --bare para criar o repositório local sem uma working tree, mas a opção --bare não mapeia as branches locais para suas origens remotas, então eu prefiro clonar uma branch padrão (nesse exemplo, a branch main), porque dessa forma eu não preciso mapear manualmente a origem das branches para cada working tree criada.\nCriando uma working tree Dentro do diretório main, use o comando git worktree add:\n1 git worktree add [path] [branch] Exemplo:\n1 2 cd main git worktree add ../featureA featureA Esse é o resultado:\n1 2 3 4 5 6 7 MeuProjeto/ \u0026lt;-- Nome do repositório ├── featureA \u0026lt;-- Nome da branch │ ├── .git \u0026lt;-- Arquivo apontando para ../main/.git │ └── README.md └── main \u0026lt;-- Nome da branch ├── .git \u0026lt;-- Repositório local └── README.md ℹ️ Você pode usar o comando git worktree add e outros comando do GIT dentro de qualquer diretório de working tree.\n⚠️ Se estiver usando windows, troque a barra no caminho de ../featureA para ..\\featureA.\nTrocando para uma working tree Apenas mude o diretório onde está trabalhando:\n1 cd ../featureA Removendo uma working tree Dentro do diretório main, use o comando git worktree remove:\n1 git worktree remove [branch] Exemplo:\n1 git worktree remove featureA ou exclua a pasta da working tree (nesse exemplo, featureA), e use o comando git worktree prune para remover as working trees que não existem mais.\nExtensão Git Worktrees para Visual Studio Code Git Worktrees é uma extensão gratuita para Visual Studio Code que nos ajuda a trabalhar com working trees.\nCriando uma working tree Abra a paleta de comandos (Ctrl+Shift+P), procure por worktree add\nTrocando para uma working tree Abra a paleta de comandos (Ctrl+Shift+P), procure por worktree list e selecione Git Worktree: List.\nSelecione a branch onde quer trabalhar e o VS Code abrirá uma nova janela com a working tree selecionada.\nRemovendo uma working tree Abra a paleta de comandos (Ctrl+Shift+P), procure por worktree remove e selecione Git Worktree: Remove.\nSelecione a branch que quer remover.\n⚠️ Você não pode remover a working tree que está aberta no VS Code.\nTrocando para uma working tree pelo Visual Studio 2022 O Visual Studio é a minha IDE favorita para trabalhar com .NET, então é importante que eu consiga trocar de forma fácil entre working trees através dele.\nUma vez que a working tree foi aberta pela primeira vez no Visual Studio, ele irá rastrear ela como um repositório na barra de status. Para trocar de working tree, basta trocar o repositório:\nReferências e links https://git-scm.com/docs/git-clone https://git-scm.com/docs/git-worktree https://marketplace.visualstudio.com/items?itemName=GitWorktrees.git-worktrees ","date":"2022-09-30T09:35:00-03:00","image":"https://blog.genezini.com/pt/p/trabalhando-em-m%C3%BAltiplas-branches-git-paralelamente/cover.pt.png","permalink":"https://blog.genezini.com/pt/p/trabalhando-em-m%C3%BAltiplas-branches-git-paralelamente/","title":"Trabalhando em múltiplas branches GIT paralelamente"},{"content":"Introdução Embora não exista um consenso sobre o escopo de um teste de integração, Martin Fowler define testes de integração restritos (Narrow), nos quais a integração entre os sistemas é testada usando substitutos (Mocks), e testes de integração amplos (Broad), que se comunicam com APIs reais.\nNesse post, explicarei como criar mocks para APIs HTTP em testes de integração restritos usando a biblioteca WireMock.Net.\nO que \u0026ldquo;mockar\u0026rdquo;? Vladimir Khorikov tem um conceito de dependências gerenciadas e não gerenciadas, que considero complementar ao conceito de Martin Fowler, para escolhermos o que deve e o que não deve ser \u0026ldquo;mockado\u0026rdquo;.\nSegundo Vladimir, dependências gerenciadas são sistemas externos controlados por nós e acessados apenas pela nossa aplicação (por exemplo, um banco de dados). Por outro lado, dependências não gerenciadas são sistemas externos não controlados por nós ou que são acessados também por outras aplicações (como uma API de terceiros e um message broker).\nVladimir defende que devemos fazer nossos testes de integração consumindo dependências gerenciadas e \u0026ldquo;mockando\u0026rdquo; dependências não gerenciadas. Eu acredito que essa definição serve mais como um norte do que como uma regra. Por exemplo, em um cenário onde nosso sistema posta mensagens em um message broker para outro sistema ler, ou seja, o message broker é uma dependência não gerenciada, podemos testar a integração com o message broker para validar que a mensagem está sendo postada no formato correto (contrato definido). Isso pode ser valioso para validar que atualizações na biblioteca usada para se comunicar com o message broker não modificou o formato e o conteúdo das mensagens.\nPor que usar mocks? O intuito dos testes de integração restritos é testar se seus componentes, testados individualmente através de testes de unidade, funcionam corretamente de forma integrada entre si. Quando consumimos uma API, seguimos um protocolo e confiamos em um contrato de comunicação, isto é, que ela vai aceitar uma entrada X e retornar uma resposta Y.\nDessa forma, o funcionamento da API externa não está no escopo dos testes integrados.\nIsso não exclui a necessidade de realizar testes funcionais; apenas diminui a quantidade necessária desses testes, que, em geral, são mais custosos de serem executados.\nRestringindo os testes de integração apenas ao nosso sistema, temos alguns benefícios:\nVelocidade nos testes, pois retiramos a latência da rede; Não dependência de dados para teste em sistemas externos; Menor fragilidade dos testes, que podem quebrar em caso de instabilidade ou de dados que foram alterados nos sistemas externos, dificultando a interpretação dos resultados; Maior confiança nos resultados dos testes. Usando WireMock.Net Nesse exemplo, construí uma API que usa o serviço PokéAPI para buscar os dados de um Pokémon e retornar os dados para o cliente da nossa API.\nController O controller é simples e usa a biblioteca Refit para abstrair a chamada da API e, por simplicidade, retorna o mesmo objeto.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 using Microsoft.AspNetCore.Mvc; using Refit; namespace PokemonInfoAPI.Controllers { [ApiController] [Route(\u0026#34;[controller]\u0026#34;)] public class PokemonInfoController : ControllerBase { private readonly IConfiguration _configuration; public PokemonInfoController(IConfiguration configuration) { _configuration = configuration; } [HttpGet(\u0026#34;{pokemonName}\u0026#34;)] public async Task\u0026lt;ActionResult\u0026lt;PokemonInfo\u0026gt;\u0026gt; GetAsync(string pokemonName) { try { var pokeApi = RestService.For\u0026lt;IPokeApi\u0026gt;(_configuration[\u0026#34;PokeApiBaseUrl\u0026#34;]); return Ok(await pokeApi.GetPokemonInfo(pokemonName)); } catch (ApiException ex) { if (ex.StatusCode == System.Net.HttpStatusCode.NotFound) { return NotFound(); } return StatusCode(500); } } } } Teste de integração padrão Começamos com um teste de integração padrão, usando a classe WebApplicationFactory do ASP.NET Core.\nO teste cria uma instância da nossa aplicação e faz uma chamada ao endpoint /pokemoninfo passando o parâmetro charmander. A chamada ao endpoint faz nossa aplicação chamar a API PokéAPI.\n⚠️ Se estiver usando a classe Startup.cs na sua aplicação, utilizar WebApplicationFactory\u0026lt;Startup\u0026gt; em vez de WebApplicationFactory\u0026lt;Program\u0026gt;.\n⚠️ Se não estiver usando Startup.cs, não é possível utilizar top-level statements na sua aplicação durante os testes.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 using FluentAssertions; using Microsoft.AspNetCore.Mvc.Testing; using System.Net; using System.Text.Json; namespace PokemonInfoAPI.IntegrationTests { public class PokemonInfoTests: IClassFixture\u0026lt;WebApplicationFactory\u0026lt;Program\u0026gt;\u0026gt; { private readonly WebApplicationFactory\u0026lt;Program\u0026gt; _factory; public PokemonInfoTests(WebApplicationFactory\u0026lt;Program\u0026gt; factory) { _factory = factory; } [Fact] public async Task Get_Existing_Pokemon_Returns_200() { //Arrange var HttpClient = Factory.CreateClient(); //Act var HttpResponse = await HttpClient.GetAsync(\u0026#34;/pokemoninfo/charmander\u0026#34;); //Assert HttpResponse.StatusCode.Should().Be(HttpStatusCode.OK); var ResponseJson = await HttpResponse.Content.ReadAsStringAsync(); var PokemonInfo = JsonSerializer.Deserialize\u0026lt;PokemonInfo\u0026gt;(ResponseJson); PokemonInfo.Should().BeEquivalentTo(ResponseObj); } } } Criando um mock para o sistema externo PokéAPI O WireMock.Net é uma biblioteca que possibilita a criação de mocks para APIs HTTP. Ele cria um servidor web no mesmo processo dos nossos testes e expõe uma URL para ser acessada pela nossa aplicação.\nPrimeiro, instalo o pacote Nuget WireMock.Net no projeto de testes.\nUtilizando o Package Manager pelo Visual Studio 1 Install-Package WireMock.Net Ou\nUtilizando o .NET CLI pela linha de comando 1 dotnet add package WireMock.Net Iniciando o servidor do WireMock.Net Para iniciar o servidor do WireMock.Net, chamo o método Start da classe WireMockServer, que retorna um objeto com os dados do servidor.\n1 var WireMockSvr = WireMockServer.Start(); Sobrescrevendo as configurações da nossa aplicação Com o servidor iniciado, sobrescrevo o parâmetro PokeApiBaseUrl, que contém a URL do PokéAPI, nas configurações da minha aplicação usando o método WithWebHostBuilder do WebApplicationFactory:\n1 2 3 4 5 6 var HttpClient = _factory .WithWebHostBuilder(builder =\u0026gt; { builder.UseSetting(\u0026#34;PokeApiBaseUrl\u0026#34;, WireMockSvr.Url); }) .CreateClient(); Criando o mock para o endpoint /pokemon Em seguida, crio o mock para o endpoint /pokemon recebendo o parâmetro charmander.\nNo exemplo abaixo, estou usando o AutoFixture para gerar um objeto com valores aleatórios, que será retornado pelo mock.\nℹ️ Usar um objeto me possibilita comparar o retorno do meu sistema com esse objeto, mas também é possível configurar o retorno a partir de um arquivo, utilizando WithBodyFromFile.\nTambém configuro os Headers que serão retornados e o status HTTP.\n1 2 3 4 5 6 7 8 9 10 11 12 13 Fixture fixture = new Fixture(); var ResponseObj = fixture.Create\u0026lt;PokemonInfo\u0026gt;(); var ResponseObjJson = JsonSerializer.Serialize(ResponseObj); WireMockSvr .Given(Request.Create() .WithPath(\u0026#34;/pokemon/charmander\u0026#34;) .UsingGet()) .RespondWith(Response.Create() .WithBody(ResponseObjJson) .WithHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .WithStatusCode(HttpStatusCode.OK)); Feito isso, minha aplicação instanciada dentro dos testes já estará consumindo o mock, em vez da API real.\nCódigo completo do teste 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 [Fact] public async Task Get_Existing_Pokemon_Returns_200() { //Arrange var WireMockSvr = WireMockServer.Start(); var HttpClient = _factory .WithWebHostBuilder(builder =\u0026gt; { builder.UseSetting(\u0026#34;PokeApiBaseUrl\u0026#34;, WireMockSvr.Url); }) .CreateClient(); Fixture fixture = new Fixture(); var ResponseObj = fixture.Create\u0026lt;PokemonInfo\u0026gt;(); var ResponseObjJson = JsonSerializer.Serialize(ResponseObj); WireMockSvr .Given(Request.Create() .WithPath(\u0026#34;/pokemon/charmander\u0026#34;) .UsingGet()) .RespondWith(Response.Create() .WithBody(ResponseObjJson) .WithHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .WithStatusCode(HttpStatusCode.OK)); //Act var HttpResponse = await HttpClient.GetAsync(\u0026#34;/pokemoninfo/charmander\u0026#34;); //Assert HttpResponse.StatusCode.Should().Be(HttpStatusCode.OK); var ResponseJson = await HttpResponse.Content.ReadAsStringAsync(); var PokemonInfo = JsonSerializer.Deserialize\u0026lt;PokemonInfo\u0026gt;(ResponseJson); PokemonInfo.Should().BeEquivalentTo(ResponseObj); WireMockSvr.Stop(); } Exemplo simulando um cenário de não sucesso Pelo contrato da API, sabemos que ela retorna o status 404 (Not Found) quando recebe um pokémon inválido como parâmetro, então criei um mock que retorna esse status ao receber o parâmetro picapau e valido que o retorno da minha aplicação está correto.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 [Fact] public async Task Get_NotExisting_Pokemon_Returns_404() { //Arrange var WireMockSvr = WireMockServer.Start(); var Factory = _factory.WithWebHostBuilder(builder =\u0026gt; { builder.UseSetting(\u0026#34;PokeApiBaseUrl\u0026#34;, WireMockSvr.Url); }); var HttpClient = Factory.CreateClient(); Fixture fixture = new Fixture(); WireMockSvr .Given(Request.Create() .WithPath(\u0026#34;/pokemon/picapau\u0026#34;) .UsingGet()) .RespondWith(Response.Create() .WithHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .WithStatusCode(HttpStatusCode.NotFound)); //Act var HttpResponse = await HttpClient .GetAsync(\u0026#34;/pokemoninfo/picapau\u0026#34;); //Assert HttpResponse.StatusCode.Should().Be(HttpStatusCode.NotFound); WireMockSvr.Stop(); } Fonte completo | https://github.com/dgenezini/PokemonInfoAPIWireMockTests\nReferências e links https://martinfowler.com/bliki/IntegrationTest.html https://khorikov.org/posts/2021-11-29-unmanaged-dependencies-explained/ https://github.com/WireMock-Net/WireMock.Net https://github.com/reactiveui/refit https://github.com/AutoFixture/AutoFixture https://github.com/fluentassertions/fluentassertions ","date":"2022-09-21T08:00:00-03:00","image":"https://blog.genezini.com/pt/p/testes-de-integracao-com-aspnet-core-e-wiremocknet/cover.pt.jpg","permalink":"https://blog.genezini.com/pt/p/testes-de-integracao-com-aspnet-core-e-wiremocknet/","title":"Testes de integração sem dependências de APIs com ASP.NET Core e WireMock.Net"}]