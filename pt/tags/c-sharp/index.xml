<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C# on Daniel Genezini</title><link>https://blog.genezini.com/pt/tags/c-sharp/</link><description>Recent content in C# on Daniel Genezini</description><generator>Hugo -- gohugo.io</generator><language>pt-br</language><copyright>2022 Daniel Genezini All rights reserved</copyright><lastBuildDate>Fri, 04 Nov 2022 07:30:00 -0300</lastBuildDate><atom:link href="https://blog.genezini.com/pt/tags/c-sharp/index.xml" rel="self" type="application/rss+xml"/><item><title>Git tips</title><link>https://blog.genezini.com/pt/p/git-tips/</link><pubDate>Fri, 04 Nov 2022 07:30:00 -0300</pubDate><guid>https://blog.genezini.com/pt/p/git-tips/</guid><description>&lt;img src="https://blog.genezini.com/cover.pt.png" alt="Featured image of post Git tips" />Introdução Referências e Links</description></item><item><title>Analisando e validando cobertura de código no .NET com Coverlet</title><link>https://blog.genezini.com/pt/p/analisando-e-validando-cobertura-de-codigo-no-.net-com-coverlet/</link><pubDate>Thu, 03 Nov 2022 08:10:00 -0300</pubDate><guid>https://blog.genezini.com/pt/p/analisando-e-validando-cobertura-de-codigo-no-.net-com-coverlet/</guid><description>&lt;img src="https://blog.genezini.com/pt/p/analisando-e-validando-cobertura-de-codigo-no-.net-com-coverlet/cover.pt.png" alt="Featured image of post Analisando e validando cobertura de código no .NET com Coverlet" />Introdução Testes automatizados são um requisito para garantir a entrega de um produto de qualidade para nossos usuários. Eles ajudam a encontrar bugs e requisitos não cumpridos ainda em tempo de desenvolvimento, mas também diminuem o custo de manutenção fazendo alterações futuras no código mais seguras. Além disso, o ato de escrever código testável, por si só, aumenta a qualidade do código, pois código testável precisa ser desacoplado.
Nesse último post da série, vou mostrar como analisar e validar uma cobertura mínima de código nas nossas aplicações, além de como utilizar testes de integração para aumentar a cobertura do código.</description></item><item><title>Validando regras de estilo de código no .NET em tempo de compilação</title><link>https://blog.genezini.com/pt/p/validando-regras-de-estilo-de-codigo-no-.net-em-tempo-de-compilacao/</link><pubDate>Tue, 25 Oct 2022 08:30:00 -0300</pubDate><guid>https://blog.genezini.com/pt/p/validando-regras-de-estilo-de-codigo-no-.net-em-tempo-de-compilacao/</guid><description>&lt;img src="https://blog.genezini.com/pt/p/validando-regras-de-estilo-de-codigo-no-.net-em-tempo-de-compilacao/cover.pt.png" alt="Featured image of post Validando regras de estilo de código no .NET em tempo de compilação" />Introdução A análise estática de código é uma ótima ferramenta para detectar alguns tipos de erros no seu código, como por exemplo, não liberar objetos que implementam IDisposable. Além disso, ela ajuda a validar se o código escrito está seguindo um padrão definido, por exemplo, utilizando PascalCase para nomes de classes e camelCase para nomes de parâmetros.
Nesse post eu vou mostrar como usar os Roslyn Analyzers com C# para validar alguns padrões de qualidade e estilo de código, exibindo erros em tempo de compilação caso alguma das regras não seja respeitada, não permitindo que as alterações cheguem às branches protegidas do repositório.</description></item><item><title>Definindo regras de formatação no .NET com EditorConfig</title><link>https://blog.genezini.com/pt/p/definindo-regras-de-formatacao-no-.net-com-editorconfig/</link><pubDate>Tue, 18 Oct 2022 08:00:00 -0300</pubDate><guid>https://blog.genezini.com/pt/p/definindo-regras-de-formatacao-no-.net-com-editorconfig/</guid><description>&lt;img src="https://blog.genezini.com/pt/p/definindo-regras-de-formatacao-no-.net-com-editorconfig/cover.pt.png" alt="Featured image of post Definindo regras de formatação no .NET com EditorConfig" />Introduction Quando trabalhamos com outras pessoas, usando editores e IDEs variadas, é comum que haja diferenças nas configurações dos mesmo, fazendo com que se perca consistência no estilo de formatação do código. Por exemplo:
Usando tabs/espaços e tamanhos de indentação diferentes, dificultando a leitura do código; Usando encodings diferentes entre os arquivos, causando erros difíceis de serem encontrados (mostrando caracteres inválidos) e quebrando testes automatizados. Nesse post eu vou mostrar como manter um padrão para todos que trabalham no código, independente do editor utilizado, e em um próximo post eu mostrarei como validar essas (e outras) regras em tempo de compilação e na esteira de integração contínua.</description></item><item><title>Testes de integração sem dependências de APIs com ASP.NET Core e WireMock.Net</title><link>https://blog.genezini.com/pt/p/testes-de-integracao-com-aspnet-core-e-wiremocknet/</link><pubDate>Wed, 21 Sep 2022 08:00:00 -0300</pubDate><guid>https://blog.genezini.com/pt/p/testes-de-integracao-com-aspnet-core-e-wiremocknet/</guid><description>&lt;img src="https://blog.genezini.com/pt/p/testes-de-integracao-com-aspnet-core-e-wiremocknet/cover.pt.jpg" alt="Featured image of post Testes de integração sem dependências de APIs com ASP.NET Core e WireMock.Net" />Introdução Embora não exista um consenso sobre o escopo de um teste de integração, Martin Fowler define testes de integração restritos (Narrow), nos quais a integração entre os sistemas é testada usando substitutos (Mocks), e testes de integração amplos (Broad), que se comunicam com APIs reais.
Nesse post, explicarei como criar mocks para APIs HTTP em testes de integração restritos usando a biblioteca WireMock.Net.
O que &amp;ldquo;mockar&amp;rdquo;? Vladimir Khorikov tem um conceito de dependências gerenciadas e não gerenciadas, que considero complementar ao conceito de Martin Fowler, para escolhermos o que deve e o que não deve ser &amp;ldquo;mockado&amp;rdquo;.</description></item></channel></rss>