<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C# on Daniel Genezini | It works on my machine</title><link>https://blog.genezini.com/categories/c-sharp/</link><description>Recent content in C# on Daniel Genezini | It works on my machine</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2022 Daniel Genezini All rights reserved</copyright><lastBuildDate>Mon, 31 Jul 2023 20:00:00 -0300</lastBuildDate><atom:link href="https://blog.genezini.com/categories/c-sharp/index.xml" rel="self" type="application/rss+xml"/><item><title>Integration tests with AWS S3 buckets using Localstack and Testcontainers</title><link>https://blog.genezini.com/p/integration-tests-with-aws-s3-buckets-using-localstack-and-testcontainers/</link><pubDate>Mon, 31 Jul 2023 20:00:00 -0300</pubDate><guid>https://blog.genezini.com/p/integration-tests-with-aws-s3-buckets-using-localstack-and-testcontainers/</guid><description>&lt;img src="https://blog.genezini.com/p/integration-tests-with-aws-s3-buckets-using-localstack-and-testcontainers/cover.jpg" alt="Featured image of post Integration tests with AWS S3 buckets using Localstack and Testcontainers" /> As I explained previously in this article, in integration tests, we should mock unmanaged dependencies (dependencies that are external to our system and not controlled by us, like APIs) but test against real managed dependencies (dependencies that are controlled by our system, like databases, queues, etc). This improves the reliability of the integration tests because the communication with these dependencies are a complex part of the system and can break with a package update, a database update or a change in a queue message format.
In this post, I&amp;rsquo;ll show how to use Localstack and Testcontainers to emulate an AWS environment for use in integration tests.</description><postDescription>
As I explained previously in this article, in integration tests, we should mock unmanaged dependencies (dependencies that are external to our system and not controlled by us, like APIs) but test against real managed dependencies (dependencies that are controlled by our system, like databases, queues, etc). This improves the reliability of the integration tests because the communication with these dependencies are a complex part of the system and can break with a package update, a database update or a change in a queue message format.
In this post, I&amp;rsquo;ll show how to use Localstack and Testcontainers to emulate an AWS environment for use in integration tests.</postDescription></item><item><title>Lessons learned from building a static code analyzer for C#</title><link>https://blog.genezini.com/p/lessons-learned-from-building-a-static-code-analyzer-for-csharp/</link><pubDate>Wed, 12 Jul 2023 20:15:00 -0300</pubDate><guid>https://blog.genezini.com/p/lessons-learned-from-building-a-static-code-analyzer-for-csharp/</guid><description>&lt;img src="https://blog.genezini.com/p/lessons-learned-from-building-a-static-code-analyzer-for-csharp/cover.jpg" alt="Featured image of post Lessons learned from building a static code analyzer for C#" /> Static code analyzers are tools used to analyze software code without executing it. They can examine the code to find code smells, vulnerabilities, potential errors, and code out of a defined standard, for example. They work by parsing the source code and evaluating its syntax (structure of the code) and semantic (meaning of the code).
Roslyn, the C# compiler, provides tools for developing Roslyn Analyzers (Static code analyzers for Roslyn), giving access to the syntax and semantic of the code, that can be executed at development and build time, providing feedback in near real-time to the developers.
In this post, I&amp;rsquo;ll show a Roslyn Analyzer I built for using Discriminated Unions in C#, requiring to check the union type before access, and talk about some lessons learned while developing it.</description><postDescription>
Static code analyzers are tools used to analyze software code without executing it. They can examine the code to find code smells, vulnerabilities, potential errors, and code out of a defined standard, for example. They work by parsing the source code and evaluating its syntax (structure of the code) and semantic (meaning of the code).
Roslyn, the C# compiler, provides tools for developing Roslyn Analyzers (Static code analyzers for Roslyn), giving access to the syntax and semantic of the code, that can be executed at development and build time, providing feedback in near real-time to the developers.
In this post, I&amp;rsquo;ll show a Roslyn Analyzer I built for using Discriminated Unions in C#, requiring to check the union type before access, and talk about some lessons learned while developing it.</postDescription></item><item><title>Building a Who's that Pokémon game for Android with .NET MAUI and Blazor Hybrid</title><link>https://blog.genezini.com/p/building-a-whos-that-pokemon-game-for-android-with-net-maui-and-blazor-hybrid/</link><pubDate>Wed, 28 Jun 2023 06:00:00 -0300</pubDate><guid>https://blog.genezini.com/p/building-a-whos-that-pokemon-game-for-android-with-net-maui-and-blazor-hybrid/</guid><description>&lt;img src="https://blog.genezini.com/p/building-a-whos-that-pokemon-game-for-android-with-net-maui-and-blazor-hybrid/cover.jpg" alt="Featured image of post Building a Who's that Pokémon game for Android with .NET MAUI and Blazor Hybrid" /> Blazor was initially developed to build interactive web applications using C#, but can now be used in many platforms when used together with .NET MAUI.
In this post, I&amp;rsquo;ll show how to use Blazor Hybrid to develop a Who&amp;rsquo;s that Pokémon game for Android.</description><postDescription>
Blazor was initially developed to build interactive web applications using C#, but can now be used in many platforms when used together with .NET MAUI.
In this post, I&amp;rsquo;ll show how to use Blazor Hybrid to develop a Who&amp;rsquo;s that Pokémon game for Android.</postDescription></item><item><title>Real-time charts with Blazor, SignalR and ApexCharts</title><link>https://blog.genezini.com/p/real-time-charts-with-blazor-signalr-and-apexcharts/</link><pubDate>Tue, 02 May 2023 06:00:00 -0300</pubDate><guid>https://blog.genezini.com/p/real-time-charts-with-blazor-signalr-and-apexcharts/</guid><description>&lt;img src="https://blog.genezini.com/p/real-time-charts-with-blazor-signalr-and-apexcharts/cover.jpg" alt="Featured image of post Real-time charts with Blazor, SignalR and ApexCharts" /> SignalR is a free open-source library for ASP.NET Core that allows the server to push real-time asynchronous messages to connected clients. It is an abstraction layer on top of WebSockets, making it easier to use and providing fallback to other forms of communication when necessary (server-sent events and long polling).
In this post, I&amp;rsquo;ll show how to build a Blazor WebAssembly app that displays real-time charts from a SignalR server.</description><postDescription>
SignalR is a free open-source library for ASP.NET Core that allows the server to push real-time asynchronous messages to connected clients. It is an abstraction layer on top of WebSockets, making it easier to use and providing fallback to other forms of communication when necessary (server-sent events and long polling).
In this post, I&amp;rsquo;ll show how to build a Blazor WebAssembly app that displays real-time charts from a SignalR server.</postDescription></item><item><title>Why my WireMock mocks aren't working?</title><link>https://blog.genezini.com/p/why-my-wiremock-mocks-arent-working/</link><pubDate>Tue, 11 Apr 2023 08:00:00 -0300</pubDate><guid>https://blog.genezini.com/p/why-my-wiremock-mocks-arent-working/</guid><description>&lt;img src="https://blog.genezini.com/p/why-my-wiremock-mocks-arent-working/cover.jpg" alt="Featured image of post Why my WireMock mocks aren't working?" /> WireMock.Net is a great tool to remove external dependencies when writing integration tests, but because it is highly configurable, it can be hard to find why its mocks aren&amp;rsquo;t working.
In this post, I&amp;rsquo;ll explain how to troubleshoot problems in its configuration and show some common problems that happen in my day-to-day work.</description><postDescription>
WireMock.Net is a great tool to remove external dependencies when writing integration tests, but because it is highly configurable, it can be hard to find why its mocks aren&amp;rsquo;t working.
In this post, I&amp;rsquo;ll explain how to troubleshoot problems in its configuration and show some common problems that happen in my day-to-day work.</postDescription></item><item><title>.NET and AWS S3 with LocalStack: How to develop with local S3 buckets</title><link>https://blog.genezini.com/p/dotnet-and-aws-s3-with-localstack-how-to-develop-with-local-s3-buckets/</link><pubDate>Mon, 13 Feb 2023 07:30:00 -0300</pubDate><guid>https://blog.genezini.com/p/dotnet-and-aws-s3-with-localstack-how-to-develop-with-local-s3-buckets/</guid><description>&lt;img src="https://blog.genezini.com/p/dotnet-and-aws-s3-with-localstack-how-to-develop-with-local-s3-buckets/cover.jpg" alt="Featured image of post .NET and AWS S3 with LocalStack: How to develop with local S3 buckets" /> LocalStack is an open-source framework that allows us to emulate the major AWS services locally, making it easier to develop and test cloud applications without incurring the cost and complexity of deploying to a real cloud environment.
In this post, I&amp;rsquo;ll show how to configure it to emulate S3 buckets and how to interact with those buckets from a C# application.</description><postDescription>
LocalStack is an open-source framework that allows us to emulate the major AWS services locally, making it easier to develop and test cloud applications without incurring the cost and complexity of deploying to a real cloud environment.
In this post, I&amp;rsquo;ll show how to configure it to emulate S3 buckets and how to interact with those buckets from a C# application.</postDescription></item><item><title>How to use C# 11 features in .NET 6 or older versions (even .NET Framework 2.0)</title><link>https://blog.genezini.com/p/how-to-use-c-sharp-11-features-in-dotnet-6-or-older-versions/</link><pubDate>Mon, 06 Feb 2023 07:30:00 -0300</pubDate><guid>https://blog.genezini.com/p/how-to-use-c-sharp-11-features-in-dotnet-6-or-older-versions/</guid><description>&lt;img src="https://blog.genezini.com/p/how-to-use-c-sharp-11-features-in-dotnet-6-or-older-versions/cover.jpg" alt="Featured image of post How to use C# 11 features in .NET 6 or older versions (even .NET Framework 2.0)" /> At each release, C# adds features that help us make our codes cleaner, more readable and more maintainable. The problem is that, because some features are dependent of runtime implementations, C# versions are generally tied to .NET runtime versions. For example, C# 11 is enabled only in .NET 7 and above.
In this post, I&amp;rsquo;ll show how to use C# 11 in older runtime version (even .NET Framework 2.0).</description><postDescription>
At each release, C# adds features that help us make our codes cleaner, more readable and more maintainable. The problem is that, because some features are dependent of runtime implementations, C# versions are generally tied to .NET runtime versions. For example, C# 11 is enabled only in .NET 7 and above.
In this post, I&amp;rsquo;ll show how to use C# 11 in older runtime version (even .NET Framework 2.0).</postDescription></item><item><title>Compile-time null safety: How to avoid NullReferenceException in C#</title><link>https://blog.genezini.com/p/compile-time-null-safety-how-to-avoid-nullreferenceexception-in-c/</link><pubDate>Mon, 30 Jan 2023 07:45:00 -0300</pubDate><guid>https://blog.genezini.com/p/compile-time-null-safety-how-to-avoid-nullreferenceexception-in-c/</guid><description>&lt;img src="https://blog.genezini.com/p/compile-time-null-safety-how-to-avoid-nullreferenceexception-in-c/cover.jpg" alt="Featured image of post Compile-time null safety: How to avoid NullReferenceException in C#" /> Softwares can fail at two different moments: compile time and runtime. In the context of errors, null is a problem because the effects of not handling them right are perceived only at runtime.
In this post, I&amp;rsquo;ll show how to use a C# language feature to move the null errors to compile time and help us avoid them at runtime.</description><postDescription>
Softwares can fail at two different moments: compile time and runtime. In the context of errors, null is a problem because the effects of not handling them right are perceived only at runtime.
In this post, I&amp;rsquo;ll show how to use a C# language feature to move the null errors to compile time and help us avoid them at runtime.</postDescription></item><item><title>How to run disposable databases for your tests. Improve your integration tests accuracy with Testcontainers</title><link>https://blog.genezini.com/p/how-to-run-disposable-databases-for-your-tests.-improve-your-integration-tests-accuracy-with-testcontainers/</link><pubDate>Mon, 09 Jan 2023 07:00:00 -0300</pubDate><guid>https://blog.genezini.com/p/how-to-run-disposable-databases-for-your-tests.-improve-your-integration-tests-accuracy-with-testcontainers/</guid><description>&lt;img src="https://blog.genezini.com/p/how-to-run-disposable-databases-for-your-tests.-improve-your-integration-tests-accuracy-with-testcontainers/cover.jpg" alt="Featured image of post How to run disposable databases for your tests. Improve your integration tests accuracy with Testcontainers" /> Integration tests are essential to ensure that the different components of our system work together as expected and continue to work after changes.
In this post, I&amp;rsquo;ll explain how to spin up disposable database containers to use in integration tests.</description><postDescription>
Integration tests are essential to ensure that the different components of our system work together as expected and continue to work after changes.
In this post, I&amp;rsquo;ll explain how to spin up disposable database containers to use in integration tests.</postDescription></item><item><title>Analyzing and enforcing .NET code coverage with coverlet</title><link>https://blog.genezini.com/p/analyzing-and-enforcing-.net-code-coverage-with-coverlet/</link><pubDate>Thu, 03 Nov 2022 08:10:00 -0300</pubDate><guid>https://blog.genezini.com/p/analyzing-and-enforcing-.net-code-coverage-with-coverlet/</guid><description>&lt;img src="https://blog.genezini.com/p/analyzing-and-enforcing-.net-code-coverage-with-coverlet/cover.png" alt="Featured image of post Analyzing and enforcing .NET code coverage with coverlet" /> Automated software tests are a requirement for ensuring we are delivering a product with quality to our users. It helps in finding bugs and requirements not fulfilled at development time, but also decreases the cost of maintenance by making the future changes to our code safer. Besides, the act of writing testable code alone increases the quality of the code we are writing because testable code has to be decoupled.
In this last post of this series, I&amp;rsquo;ll show how to analyze and enforce a minimum code coverage in our applications, and how to use integration tests to increase our testing surface.</description><postDescription>
Automated software tests are a requirement for ensuring we are delivering a product with quality to our users. It helps in finding bugs and requirements not fulfilled at development time, but also decreases the cost of maintenance by making the future changes to our code safer. Besides, the act of writing testable code alone increases the quality of the code we are writing because testable code has to be decoupled.
In this last post of this series, I&amp;rsquo;ll show how to analyze and enforce a minimum code coverage in our applications, and how to use integration tests to increase our testing surface.</postDescription></item><item><title>Enforcing .NET code style rules at compile time</title><link>https://blog.genezini.com/p/enforcing-.net-code-style-rules-at-compile-time/</link><pubDate>Tue, 25 Oct 2022 08:00:00 -0300</pubDate><guid>https://blog.genezini.com/p/enforcing-.net-code-style-rules-at-compile-time/</guid><description>&lt;img src="https://blog.genezini.com/p/enforcing-.net-code-style-rules-at-compile-time/cover.png" alt="Featured image of post Enforcing .NET code style rules at compile time" /> Static code analysis is a great tool for spotting some kinds of error in your code, for example, not disposing of objects that implement IDisposable. Also, it helps to enforce and validate if the code written is following a defined standard, for example, using PascalCase for class names and camelCase for parameter names.
In this post I&amp;rsquo;ll show how to use Roslyn Analyzers with C# to enforce some standards of code quality and code style on your code, throwing errors at compile time if any rules are not being respected and not allowing the code to be pushed to protected branches of the repository.</description><postDescription>
Static code analysis is a great tool for spotting some kinds of error in your code, for example, not disposing of objects that implement IDisposable. Also, it helps to enforce and validate if the code written is following a defined standard, for example, using PascalCase for class names and camelCase for parameter names.
In this post I&amp;rsquo;ll show how to use Roslyn Analyzers with C# to enforce some standards of code quality and code style on your code, throwing errors at compile time if any rules are not being respected and not allowing the code to be pushed to protected branches of the repository.</postDescription></item><item><title>Defining formatting rules in .NET with EditorConfig</title><link>https://blog.genezini.com/p/defining-formatting-rules-in-.net-with-editorconfig/</link><pubDate>Tue, 18 Oct 2022 08:00:00 -0300</pubDate><guid>https://blog.genezini.com/p/defining-formatting-rules-in-.net-with-editorconfig/</guid><description>&lt;img src="https://blog.genezini.com/p/defining-formatting-rules-in-.net-with-editorconfig/cover.png" alt="Featured image of post Defining formatting rules in .NET with EditorConfig" /> When working with other people and multiple editors/IDEs, it is common to have different editor settings, losing consistency in formatting styles of the code. For example:
Using tabs/spaces and different sizes of indentation, making your code harder to read; Using different encoding between files, causing hard to find bugs at runtime (showing invalid characters) and breaking automated tests. In this post I&amp;rsquo;ll show how to maintain a standard for everyone who works in the code, no matter the editor used, and in a next post I&amp;rsquo;ll show how to enforce these (and other) rules on build and in the continuous integration pipeline.</description><postDescription>
When working with other people and multiple editors/IDEs, it is common to have different editor settings, losing consistency in formatting styles of the code. For example:
Using tabs/spaces and different sizes of indentation, making your code harder to read; Using different encoding between files, causing hard to find bugs at runtime (showing invalid characters) and breaking automated tests. In this post I&amp;rsquo;ll show how to maintain a standard for everyone who works in the code, no matter the editor used, and in a next post I&amp;rsquo;ll show how to enforce these (and other) rules on build and in the continuous integration pipeline.</postDescription></item><item><title>Integration tests without API dependencies with ASP.NET Core and WireMock.Net</title><link>https://blog.genezini.com/p/integration-tests-without-api-dependencies-with-asp.net-core-and-wiremock.net/</link><pubDate>Sun, 25 Sep 2022 08:00:00 -0300</pubDate><guid>https://blog.genezini.com/p/integration-tests-without-api-dependencies-with-asp.net-core-and-wiremock.net/</guid><description>&lt;img src="https://blog.genezini.com/p/integration-tests-without-api-dependencies-with-asp.net-core-and-wiremock.net/cover.jpg" alt="Featured image of post Integration tests without API dependencies with ASP.NET Core and WireMock.Net" /> Although there are many definitions about the scope of an integration test, Martin Fowler defines Narrow integration tests, where the integration with other systems are tested using mocks, and Broad integration tests, where they communicate using real APIs.
In this post, I&amp;rsquo;ll explain how to create mocks for HTTP APIs in narrow integration tests using the WireMock.Net library.</description><postDescription>
Although there are many definitions about the scope of an integration test, Martin Fowler defines Narrow integration tests, where the integration with other systems are tested using mocks, and Broad integration tests, where they communicate using real APIs.
In this post, I&amp;rsquo;ll explain how to create mocks for HTTP APIs in narrow integration tests using the WireMock.Net library.</postDescription></item></channel></rss>