[{"content":"Introduction Visual Studio Code is the most used IDE according to the Stack Overflow 2022\u0026rsquo;s Developer Survey and it has lots of extensions to help us be more productive. Even developers who use another main IDE probably use VS Code for some part of their jobs.\nIn this post I\u0026rsquo;ll show some of the extensions that I use to work, study and write this blog.\n1 - Project Manager Project Manager creates an icon in the side bar and lets you save opened folders for quick access. This way you don\u0026rsquo;t have to look for the project folder every time you open it; just open VS Code and select it from the menu.\nI use it in combination with the Git Worktree extension that I talked about in my other post. I save my long lived branches (for example, the main branch) as a project and then I can switch to other worktrees from there.\nIt also allows you to tag the projects for better organization, so I tag the different components of a solution with the project name.\nDownload\n2 - Compare Folders Compare Folders shows the difference between two folders\u0026rsquo; content and displays an editable comparison of the files side by side. It also allows you to copy the files present on only one side to the other.\nI use it mostly to compare two branches or two versions of a repository.\nDownload\n3 - Path Intellisense Path Intellisense shows an intellisense menu for choosing a file name. It works with HTML, CSS, Typescript, Javascript and other types of files.\nDownload\n4 - Draw.io Integration Draw.io is a free and open source drawing software that can be used to create diagrams, wireframes, etc.\nThis extension allows you to open and edit your .drawio files inside VS Code.\nDownload\n5 - Excalidraw Excalidraw is a whiteboard tool that lets you sketch diagrams that have a hand-drawn feel to them. Just like the Draw.io Integration, this extension allows you to open and edit .excalidraw files inside VS Code.\nDownload\n6 - Docker for Visual Studio Code This extension by Microsoft lets you manage docker images, containers, networks and volumes. It is a great alternative for the Docker Desktop Dashboard, that is now paid for commercial use.\nIt is really useful for attaching to a running container\u0026rsquo;s shell or looking into its logs with just one click. It also lets you open and edit files inside the container.\nDownload\n7 - vs-openapi-designer This extension renders the OpenAPI YAML/JSON document in a side panel for preview. It helps a lot in validating the complex API contracts that have lots of files.\nDownload\n8 - Terraform Terraform extension adds syntax support for .tf file, with snippets and intellisense.\nDownload\n9 - VSCode Great Icons A really well done pack of icons for VS Code. I like it because it has just two variations for the folders, keeping it cleaner than other icons packs, who end up leaving the files explorer confusing.\nDownload\n10 - Color Highlight Color Highlight shows the preview for colors in your CSS and HTML files.\nDownload\n11 - Import Cost This extension displays inline information of the size of the imported package. It uses webpack to detect the package size and works with import and require().\nDownload\n","date":"2022-10-11T07:00:00-03:00","image":"https://blog.genezini.com/p/vs-code-extensions-worth-trying-out/cover.png","permalink":"https://blog.genezini.com/p/vs-code-extensions-worth-trying-out/","title":"VS Code extensions worth trying out"},{"content":"Introduction When working on a project, many times we have to switch to a different branch to help a colleague, fix a bug, or to work on another feature (because of a change in priorities or blocks).\nIn these situations, we have some options:\nClone again to another folder: This was the option that I used up until some time ago, but if you are working on a big code base, it may take some time to download the remote repository and it will use more space in the disk because you will end up with one copy of the repository for each branch;\nStash or commit changes and checkout the other branch: This is ok, but it takes more steps and doesn\u0026rsquo;t allow for multiple branches checked out in parallel;\nAdd a new working tree: This is what I prefer to do because I can have only one local repository shared between the branches.\nIn this post, I\u0026rsquo;ll show how to use git working trees to make those branch switches easier.\nBasics of how a GIT repository works When we use the git clone command, GIT creates two things in the destination: a working tree and a copy of the remote repository (in a .git folder inside the working tree directory).\nℹ️ git clone --bare clones only the repository in the root folder, without the working tree.\nRepository The GIT repository is a structured directory where GIT stores its objects, branches, and other components used to control the versions of our files.\nWorking tree The working tree is where the actual files we work on are stored. When we use git checkout, GIT changes all the files in the working tree to reflect the branch we are working on.\nExample 1 git clone https://github.com/dgenezini/MyProject.git MyProject Within the repository, there are a lot of files and folders, but, for the scope of this post, these are the most important ones:\nobjects = Directory storing blobs (files), trees (directories), and commits; refs = Directory storing pointers to the commits that are the heads of each branch or tag in the repository; HEAD = File pointing to the branch or tag that is checked in in the working tree; index = File used to control what is staged. Why use GIT Worktree? Using the git worktree command, we can create multiple working trees pointing to the same local repository, sharing most of the repository between them.\nInstead of a .git directory, the additional working trees have a .git file with a pointer to a working tree folder inside the local repository.\nIn the working tree folder, we have the GIT components that are not shared with the other working trees. Note that most of the repository, including the objects folder (files, directories and commits), is shared.\nThese are the main components in the working tree folders:\nHEAD = File pointing to the branch that is checked out in the working tree; index = File used to control what is staged in the working tree; commondir = File pointing to the local GIT repository. Using GIT Worktree I like to have all the working trees as subfolders, so I start by creating a folder with the name of the repository and cloning the default branch to a folder with the name of the branch (in my case, main).\n1 2 mkdir MyProject \u0026amp;\u0026amp; cd MyProject git clone https://github.com/dgenezini/MyProject.git main This is the result I want:\n1 2 3 4 MyProject/ \u0026lt;-- My repo name └── main \u0026lt;-- Branch name ├── .git \u0026lt;-- Local repository └── README.md ℹ️ Some people use git clone --bare to pull the repository without a working tree, but the --bare option does not map the branches to their remote origins, so I prefer to clone my default branch (in this example, the main branch), because it is a long living branch, that way I don\u0026rsquo;t have to manually map the remote origins for every working tree created.\nAdding a working tree Inside the main directory, use the git worktree add command:\n1 git worktree add [path] [branch] Example:\n1 2 cd main git worktree add ../featureA featureA This is will be the result:\n1 2 3 4 5 6 7 MyProject/ \u0026lt;-- My repo name ├── featureA \u0026lt;-- Branch name │ ├── .git \u0026lt;-- File pointing to ../main/.git │ └── README.md └── main \u0026lt;-- Branch name ├── .git \u0026lt;-- Git local repository └── README.md ℹ️ You can use the git worktree add and other git commands inside any working tree directory.\n⚠️ If you are using windows, change the slash on the path from ../featureA to ..\\featureA.\nChanging to a working tree Just change the directory you are working on:\n1 cd ../featureA Removing a working tree Inside the main directory, use the git worktree remove command:\n1 git worktree remove [branch] Example:\n1 git worktree remove featureA or just delete the working tree folder (featureA in this example), then use git worktree prune to clean the invalid working trees.\nGit Worktrees extension for Visual Studio Code Git Worktrees is a free extension for Visual Studio Code that helps us work with git working trees.\nAdding a working tree Open the Command Palette (Ctrl+Shift+P) and type worktree add\nChanging to a working tree Open the Command Palette (Ctrl+Shift+P), search for worktree list and select Git Worktree: List.\nSelect the branch you want to work on and VS Code will open another window in that working tree.\nRemoving a working tree Open the Command Palette (Ctrl+Shift+P), search for worktree remove and select Git Worktree: Remove.\nSelect the branch you want to remove.\n⚠️ You can\u0026rsquo;t remove the working tree you have currently open in VS Code.\nChanging the working tree from Visual Studio 2022 Visual Studio is my favorite IDE for working with .NET, so it is important that I can change easily between working trees from within it.\nOnce you open the project from the working tree for the first time, Visual Studio will keep track of the working tree as a repository in the status bar. Just change it from there and it will load the project.\nReferences e links https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens https://marketplace.visualstudio.com/items?itemName=GitWorktrees.git-worktrees ","date":"2022-09-30T09:35:00-03:00","image":"https://blog.genezini.com/p/working-on-multiple-git-branches-in-parallel/cover.png","permalink":"https://blog.genezini.com/p/working-on-multiple-git-branches-in-parallel/","title":"Working on multiple GIT branches in parallel"},{"content":"Introduction Although there are many definitions about the scope of an integration test, Martin Fowler defines Narrow integration tests, where the integration with other systems are tested using mocks, and Broad integration tests, where they communicate using real APIs.\nIn this post, I\u0026rsquo;ll explain how to create mocks for HTTP APIs in narrow integration tests using the WireMock.Net library.\nWhat should we mock? Vladimir Khorikov has a concept of managed dependencies and unmanaged dependencies, which I consider complementary to Martin Fowler\u0026rsquo;s, to choose what should be to mocked.\nManaged dependencies are external systems controlled by us and accessed only by our application (for example, a database). On the other side, unmanaged dependencies are external systems not controlled by us or also accessed by other applications (like a third party API or a message broker).\nVladimir says that we should test our system against managed dependencies, while mocking unmanaged dependencies. I believe this definition is more like a guideline than a rule. For example, in a scenario where our application posts in a message broker for other system to read, that is, the message broker is an unmanaged dependency, we could test the integration with the message broker to validate that the message is being written in the right format (according to contract). This can have value if we want to test if updates to the library used to communicate with the message broker didn\u0026rsquo;t introduce breaking changes in the message.\nWhy use mocks? The reason we use integration tests is to test our components (or classes), which are tested independently in unit tests, working in communication with each other. When we interact with an API, we follow a protocol and trust a contract of communication, that is, that the API will accept parameters X as input and will return an response Y.\nThat way, the inner works of that external API is not in the scope of our integration tests.\nThis doesn\u0026rsquo;t remove the requirement of functional tests; it only reduces the amount of those tests, which are more expensive to execute.\nReducing the integration tests only to our application, we have some benefits:\nSpeed of the tests, because we remove the network latency; No need of data in external systems to execute the tests; Reduced brittleness of the tests, that could break in case of the external API instability or external data that changed; More trust in the test results. Using WireMock.Net In this example, I\u0026rsquo;ve built an API that consumes the PokéAPI service to look for a Pokémon data and return it to the client.\nController The controller is simple and use the Refit library to abstract the PokéAPI call and then, returns the data.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 using Microsoft.AspNetCore.Mvc; using Refit; namespace PokemonInfoAPI.Controllers { [ApiController] [Route(\u0026#34;[controller]\u0026#34;)] public class PokemonInfoController : ControllerBase { private readonly IConfiguration _configuration; public PokemonInfoController(IConfiguration configuration) { _configuration = configuration; } [HttpGet(\u0026#34;{pokemonName}\u0026#34;)] public async Task\u0026lt;ActionResult\u0026lt;PokemonInfo\u0026gt;\u0026gt; GetAsync(string pokemonName) { try { var pokeApi = RestService.For\u0026lt;IPokeApi\u0026gt;(_configuration[\u0026#34;PokeApiBaseUrl\u0026#34;]); return Ok(await pokeApi.GetPokemonInfo(pokemonName)); } catch (ApiException ex) { if (ex.StatusCode == System.Net.HttpStatusCode.NotFound) { return NotFound(); } return StatusCode(500); } } } } Default integration test We start with a default integration test, using ASP.NET Core\u0026rsquo;s WebApplicationFactory class. The test creates an instance of our application e makes a request to the /pokemoninfo endpoint with the parameter charmander. Out application calls the PokéAPI.\n⚠️ If you\u0026rsquo;re using the Startup.cs class in your application, instanciate WebApplicationFactory\u0026lt;Startup\u0026gt; instead of WebApplicationFactory\u0026lt;Program\u0026gt;.\n⚠️ If you\u0026rsquo;re not using the Startup.cs class, it\u0026rsquo;s not possible to use top-level statements in your application to use the WebApplicationFactory in your tests.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 using FluentAssertions; using Microsoft.AspNetCore.Mvc.Testing; using System.Net; using System.Text.Json; namespace PokemonInfoAPI.IntegrationTests { public class PokemonInfoTests: IClassFixture\u0026lt;WebApplicationFactory\u0026lt;Program\u0026gt;\u0026gt; { private readonly WebApplicationFactory\u0026lt;Program\u0026gt; _factory; public PokemonInfoTests(WebApplicationFactory\u0026lt;Program\u0026gt; factory) { _factory = factory; } [Fact] public async Task Get_Existing_Pokemon_Returns_200() { //Arrange var HttpClient = Factory.CreateClient(); //Act var HttpResponse = await HttpClient.GetAsync(\u0026#34;/pokemoninfo/charmander\u0026#34;); //Assert HttpResponse.StatusCode.Should().Be(HttpStatusCode.OK); var ResponseJson = await HttpResponse.Content.ReadAsStringAsync(); var PokemonInfo = JsonSerializer.Deserialize\u0026lt;PokemonInfo\u0026gt;(ResponseJson); PokemonInfo.Should().BeEquivalentTo(ResponseObj); } } } Setting up a mock for PokéAPI WireMock.Net is a library that let you create mocks for HTTP APIs. It creates a web server in the same process of our test and exposes an URL to be used by out application during the tests.\nFirst, I install the WireMock.Net nuget package in my tests project no projeto de testes.\nUsing Visual Studio Package Manager 1 Install-Package WireMock.Net Or\nUsing .NET CLI 1 dotnet add package WireMock.Net Starting WireMock.Net server To start the WireMock.Net server, I call the Start method of the WireMockServer class, and it returns an object with the server data.\n1 var WireMockSvr = WireMockServer.Start(); Overriding out application configurations With the server started, I override the PokeApiBaseUrl parameter, which holds the PokéAPI URL, in my application configurations using the method WithWebHostBuilder of the WebApplicationFactory:\n1 2 3 4 5 6 var HttpClient = _factory .WithWebHostBuilder(builder =\u0026gt; { builder.UseSetting(\u0026#34;PokeApiBaseUrl\u0026#34;, WireMockSvr.Url); }) .CreateClient(); Mocking the /pokemon endpoint Then, I create the mock for the /pokemon endpoint receiving the parameter value charmander.\nIn the example below, I\u0026rsquo;m using the AutoFixture library to generate an object with random values, that will be returned by the mocked API.\nℹ️ By using an object, I can compare the return of my application with this object, but it\u0026rsquo;s also possible to configure the return based on an file with a JSON, with the WithBodyFromFile method.\nAlso, I set the headers that will be returned and the HTTP status of the response.\n1 2 3 4 5 6 7 8 9 10 11 12 13 Fixture fixture = new Fixture(); var ResponseObj = fixture.Create\u0026lt;PokemonInfo\u0026gt;(); var ResponseObjJson = JsonSerializer.Serialize(ResponseObj); WireMockSvr .Given(Request.Create() .WithPath(\u0026#34;/pokemon/charmander\u0026#34;) .UsingGet()) .RespondWith(Response.Create() .WithBody(ResponseObjJson) .WithHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .WithStatusCode(HttpStatusCode.OK)); After that, my application inside the tests will be using the mocked version of the PokéAPI.\nComplete test code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 [Fact] public async Task Get_Existing_Pokemon_Returns_200() { //Arrange var WireMockSvr = WireMockServer.Start(); var HttpClient = _factory .WithWebHostBuilder(builder =\u0026gt; { builder.UseSetting(\u0026#34;PokeApiBaseUrl\u0026#34;, WireMockSvr.Url); }) .CreateClient(); Fixture fixture = new Fixture(); var ResponseObj = fixture.Create\u0026lt;PokemonInfo\u0026gt;(); var ResponseObjJson = JsonSerializer.Serialize(ResponseObj); WireMockSvr .Given(Request.Create() .WithPath(\u0026#34;/pokemon/charmander\u0026#34;) .UsingGet()) .RespondWith(Response.Create() .WithBody(ResponseObjJson) .WithHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .WithStatusCode(HttpStatusCode.OK)); //Act var HttpResponse = await HttpClient.GetAsync(\u0026#34;/pokemoninfo/charmander\u0026#34;); //Assert HttpResponse.StatusCode.Should().Be(HttpStatusCode.OK); var ResponseJson = await HttpResponse.Content.ReadAsStringAsync(); var PokemonInfo = JsonSerializer.Deserialize\u0026lt;PokemonInfo\u0026gt;(ResponseJson); PokemonInfo.Should().BeEquivalentTo(ResponseObj); WireMockSvr.Stop(); } Example of an unsuccessfull API call scenario Based on the contract of the API, we know that it return the status 404 (Not Found) when the parameter is not a valid Pokémon name, so I created a mock that returns this status for the parameter value woodywoodpecker and assert that my application response is correct for this scenario.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 [Fact] public async Task Get_NotExisting_Pokemon_Returns_404() { //Arrange var WireMockSvr = WireMockServer.Start(); var Factory = _factory.WithWebHostBuilder(builder =\u0026gt; { builder.UseSetting(\u0026#34;PokeApiBaseUrl\u0026#34;, WireMockSvr.Url); }); var HttpClient = Factory.CreateClient(); Fixture fixture = new Fixture(); WireMockSvr .Given(Request.Create() .WithPath(\u0026#34;/pokemon/woodywoodpecker\u0026#34;) .UsingGet()) .RespondWith(Response.Create() .WithHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .WithStatusCode(HttpStatusCode.NotFound)); //Act var HttpResponse = await HttpClient .GetAsync(\u0026#34;/pokemoninfo/woodywoodpecker\u0026#34;); //Assert HttpResponse.StatusCode.Should().Be(HttpStatusCode.NotFound); WireMockSvr.Stop(); } Source code | https://github.com/dgenezini/PokemonInfoAPIWireMockTests\nReferences and links https://martinfowler.com/bliki/IntegrationTest.html https://khorikov.org/posts/2021-11-29-unmanaged-dependencies-explained/ https://github.com/WireMock-Net/WireMock.Net https://github.com/reactiveui/refit https://github.com/AutoFixture/AutoFixture https://github.com/fluentassertions/fluentassertions ","date":"2022-09-25T08:00:00-03:00","image":"https://blog.genezini.com/p/integration-tests-without-api-dependencies-with-asp.net-core-and-wiremock.net/cover.jpg","permalink":"https://blog.genezini.com/p/integration-tests-without-api-dependencies-with-asp.net-core-and-wiremock.net/","title":"Integration tests without API dependencies with ASP.NET Core and WireMock.Net"}]