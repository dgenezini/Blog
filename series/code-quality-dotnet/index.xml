<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code Quality in .NET on Daniel Genezini</title><link>https://blog.genezini.com/series/code-quality-dotnet/</link><description>Recent content in Code Quality in .NET on Daniel Genezini</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2022 Daniel Genezini All rights reserved</copyright><lastBuildDate>Thu, 03 Nov 2022 08:10:00 -0300</lastBuildDate><atom:link href="https://blog.genezini.com/series/code-quality-dotnet/index.xml" rel="self" type="application/rss+xml"/><item><title>Analyzing and enforcing .NET code coverage with coverlet</title><link>https://blog.genezini.com/p/analyzing-and-enforcing-.net-code-coverage-with-coverlet/</link><pubDate>Thu, 03 Nov 2022 08:10:00 -0300</pubDate><guid>https://blog.genezini.com/p/analyzing-and-enforcing-.net-code-coverage-with-coverlet/</guid><description>&lt;img src="https://blog.genezini.com/p/analyzing-and-enforcing-.net-code-coverage-with-coverlet/cover.png" alt="Featured image of post Analyzing and enforcing .NET code coverage with coverlet" /> Automated software tests are a requirement for ensuring we are delivering a product with quality to our users. It helps in finding bugs and requirements not fulfilled at development time, but also decreases the cost of maintenance by making the future changes to our code safer. Besides, the act of writing testable code alone increases the quality of the code we are writing because testable code has to be decoupled.
In this last post of this series, I&amp;rsquo;ll show how to analyze and enforce a minimum code coverage in our applications, and how to use integration tests to increase our testing surface.</description><postDescription>
Automated software tests are a requirement for ensuring we are delivering a product with quality to our users. It helps in finding bugs and requirements not fulfilled at development time, but also decreases the cost of maintenance by making the future changes to our code safer. Besides, the act of writing testable code alone increases the quality of the code we are writing because testable code has to be decoupled.
In this last post of this series, I&amp;rsquo;ll show how to analyze and enforce a minimum code coverage in our applications, and how to use integration tests to increase our testing surface.</postDescription></item><item><title>Enforcing .NET code style rules at compile time</title><link>https://blog.genezini.com/p/enforcing-.net-code-style-rules-at-compile-time/</link><pubDate>Tue, 25 Oct 2022 08:00:00 -0300</pubDate><guid>https://blog.genezini.com/p/enforcing-.net-code-style-rules-at-compile-time/</guid><description>&lt;img src="https://blog.genezini.com/p/enforcing-.net-code-style-rules-at-compile-time/cover.png" alt="Featured image of post Enforcing .NET code style rules at compile time" /> Static code analysis is a great tool for spotting some kinds of error in your code, for example, not disposing of objects that implement IDisposable. Also, it helps to enforce and validate if the code written is following a defined standard, for example, using PascalCase for class names and camelCase for parameter names.
In this post I&amp;rsquo;ll show how to use Roslyn Analyzers with C# to enforce some standards of code quality and code style on your code, throwing errors at compile time if any rules are not being respected and not allowing the code to be pushed to protected branches of the repository.</description><postDescription>
Static code analysis is a great tool for spotting some kinds of error in your code, for example, not disposing of objects that implement IDisposable. Also, it helps to enforce and validate if the code written is following a defined standard, for example, using PascalCase for class names and camelCase for parameter names.
In this post I&amp;rsquo;ll show how to use Roslyn Analyzers with C# to enforce some standards of code quality and code style on your code, throwing errors at compile time if any rules are not being respected and not allowing the code to be pushed to protected branches of the repository.</postDescription></item><item><title>Defining formatting rules in .NET with EditorConfig</title><link>https://blog.genezini.com/p/defining-formatting-rules-in-.net-with-editorconfig/</link><pubDate>Tue, 18 Oct 2022 08:00:00 -0300</pubDate><guid>https://blog.genezini.com/p/defining-formatting-rules-in-.net-with-editorconfig/</guid><description>&lt;img src="https://blog.genezini.com/p/defining-formatting-rules-in-.net-with-editorconfig/cover.png" alt="Featured image of post Defining formatting rules in .NET with EditorConfig" /> When working with other people and multiple editors/IDEs, it is common to have different editor settings, losing consistency in formatting styles of the code. For example:
Using tabs/spaces and different sizes of indentation, making your code harder to read; Using different encoding between files, causing hard to find bugs at runtime (showing invalid characters) and breaking automated tests. In this post I&amp;rsquo;ll show how to maintain a standard for everyone who works in the code, no matter the editor used, and in a next post I&amp;rsquo;ll show how to enforce these (and other) rules on build and in the continuous integration pipeline.</description><postDescription>
When working with other people and multiple editors/IDEs, it is common to have different editor settings, losing consistency in formatting styles of the code. For example:
Using tabs/spaces and different sizes of indentation, making your code harder to read; Using different encoding between files, causing hard to find bugs at runtime (showing invalid characters) and breaking automated tests. In this post I&amp;rsquo;ll show how to maintain a standard for everyone who works in the code, no matter the editor used, and in a next post I&amp;rsquo;ll show how to enforce these (and other) rules on build and in the continuous integration pipeline.</postDescription></item></channel></rss>