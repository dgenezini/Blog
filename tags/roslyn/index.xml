<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Roslyn on Daniel Genezini | It works on my machine</title><link>https://blog.genezini.com/tags/roslyn/</link><description>Recent content in Roslyn on Daniel Genezini | It works on my machine</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2022 Daniel Genezini All rights reserved</copyright><lastBuildDate>Wed, 12 Jul 2023 20:15:00 -0300</lastBuildDate><atom:link href="https://blog.genezini.com/tags/roslyn/index.xml" rel="self" type="application/rss+xml"/><item><title>Lessons learned from building a static code analyzer for C#</title><link>https://blog.genezini.com/p/lessons-learned-from-building-a-static-code-analyzer-for-csharp/</link><pubDate>Wed, 12 Jul 2023 20:15:00 -0300</pubDate><guid>https://blog.genezini.com/p/lessons-learned-from-building-a-static-code-analyzer-for-csharp/</guid><description>&lt;img src="https://blog.genezini.com/p/lessons-learned-from-building-a-static-code-analyzer-for-csharp/cover.jpg" alt="Featured image of post Lessons learned from building a static code analyzer for C#" /> Static code analyzers are tools used to analyze software code without executing it. They can examine the code to find code smells, vulnerabilities, potential errors, and code out of a defined standard, for example. They work by parsing the source code and evaluating its syntax (structure of the code) and semantic (meaning of the code).
Roslyn, the C# compiler, provides tools for developing Roslyn Analyzers (Static code analyzers for Roslyn), giving access to the syntax and semantic of the code, that can be executed at development and build time, providing feedback in near real-time to the developers.
In this post, I&amp;rsquo;ll show a Roslyn Analyzer I built for using Discriminated Unions in C#, requiring to check the union type before access, and talk about some lessons learned while developing it.</description><postDescription>
Static code analyzers are tools used to analyze software code without executing it. They can examine the code to find code smells, vulnerabilities, potential errors, and code out of a defined standard, for example. They work by parsing the source code and evaluating its syntax (structure of the code) and semantic (meaning of the code).
Roslyn, the C# compiler, provides tools for developing Roslyn Analyzers (Static code analyzers for Roslyn), giving access to the syntax and semantic of the code, that can be executed at development and build time, providing feedback in near real-time to the developers.
In this post, I&amp;rsquo;ll show a Roslyn Analyzer I built for using Discriminated Unions in C#, requiring to check the union type before access, and talk about some lessons learned while developing it.</postDescription></item><item><title>Compile-time null safety: How to avoid NullReferenceException in C#</title><link>https://blog.genezini.com/p/compile-time-null-safety-how-to-avoid-nullreferenceexception-in-c/</link><pubDate>Mon, 30 Jan 2023 07:45:00 -0300</pubDate><guid>https://blog.genezini.com/p/compile-time-null-safety-how-to-avoid-nullreferenceexception-in-c/</guid><description>&lt;img src="https://blog.genezini.com/p/compile-time-null-safety-how-to-avoid-nullreferenceexception-in-c/cover.jpg" alt="Featured image of post Compile-time null safety: How to avoid NullReferenceException in C#" /> Softwares can fail at two different moments: compile time and runtime. In the context of errors, null is a problem because the effects of not handling them right are perceived only at runtime.
In this post, I&amp;rsquo;ll show how to use a C# language feature to move the null errors to compile time and help us avoid them at runtime.</description><postDescription>
Softwares can fail at two different moments: compile time and runtime. In the context of errors, null is a problem because the effects of not handling them right are perceived only at runtime.
In this post, I&amp;rsquo;ll show how to use a C# language feature to move the null errors to compile time and help us avoid them at runtime.</postDescription></item><item><title>Enforcing .NET code style rules at compile time</title><link>https://blog.genezini.com/p/enforcing-.net-code-style-rules-at-compile-time/</link><pubDate>Tue, 25 Oct 2022 08:00:00 -0300</pubDate><guid>https://blog.genezini.com/p/enforcing-.net-code-style-rules-at-compile-time/</guid><description>&lt;img src="https://blog.genezini.com/p/enforcing-.net-code-style-rules-at-compile-time/cover.png" alt="Featured image of post Enforcing .NET code style rules at compile time" /> Static code analysis is a great tool for spotting some kinds of error in your code, for example, not disposing of objects that implement IDisposable. Also, it helps to enforce and validate if the code written is following a defined standard, for example, using PascalCase for class names and camelCase for parameter names.
In this post I&amp;rsquo;ll show how to use Roslyn Analyzers with C# to enforce some standards of code quality and code style on your code, throwing errors at compile time if any rules are not being respected and not allowing the code to be pushed to protected branches of the repository.</description><postDescription>
Static code analysis is a great tool for spotting some kinds of error in your code, for example, not disposing of objects that implement IDisposable. Also, it helps to enforce and validate if the code written is following a defined standard, for example, using PascalCase for class names and camelCase for parameter names.
In this post I&amp;rsquo;ll show how to use Roslyn Analyzers with C# to enforce some standards of code quality and code style on your code, throwing errors at compile time if any rules are not being respected and not allowing the code to be pushed to protected branches of the repository.</postDescription></item></channel></rss>